/* tslint:disable */

/* eslint-disable */

/**
 * Core API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios, { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios';

// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from './base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
import { Configuration } from './configuration';

/**
 *
 * @export
 * @interface AppMessage
 */
export interface AppMessage {
  /**
   * attributes
   * @type {Array<string>}
   * @memberof AppMessage
   */
  attributes: Array<string>;
  /**
   *
   * @type {string}
   * @memberof AppMessage
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AppMessage
   */
  message: string;
}
/**
 *
 * @export
 * @interface ApproveWithdrawRequest
 */
export interface ApproveWithdrawRequest {
  /**
   *
   * @type {string}
   * @memberof ApproveWithdrawRequest
   */
  approvedByUserId: string;
  /**
   *
   * @type {number}
   * @memberof ApproveWithdrawRequest
   */
  withdrawId: number;
}
/**
 * Cancel Incentives Request
 * @export
 * @interface CancelPlayerBonusRequest
 */
export interface CancelPlayerBonusRequest {
  /**
   *
   * @type {string}
   * @memberof CancelPlayerBonusRequest
   */
  cancellationReason: string | null;
  /**
   *
   * @type {number}
   * @memberof CancelPlayerBonusRequest
   */
  playerBonusId: number;
}
/**
 *
 * @export
 * @interface CancelWithdrawRequest
 */
export interface CancelWithdrawRequest {
  /**
   *
   * @type {number}
   * @memberof CancelWithdrawRequest
   */
  withdrawId: number;
}
/**
 *
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
  /**
   *
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  newPassword: string;
  /**
   *
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  token: string;
}
/**
 *
 * @export
 * @interface ChangePasswordResponse
 */
export interface ChangePasswordResponse {
  /**
   *
   * @type {number}
   * @memberof ChangePasswordResponse
   */
  playerId: number;
}
/**
 * change personal information request
 * @export
 * @interface ChangePersonalInformationRequest
 */
export interface ChangePersonalInformationRequest {
  /**
   *
   * @type {string}
   * @memberof ChangePersonalInformationRequest
   */
  displayName?: string | null;
  /**
   *
   * @type {string}
   * @memberof ChangePersonalInformationRequest
   */
  genderId: string;
  /**
   *
   * @type {string}
   * @memberof ChangePersonalInformationRequest
   */
  phoneCode: string;
  /**
   *
   * @type {string}
   * @memberof ChangePersonalInformationRequest
   */
  phoneNumber: string;
}
/**
 * change personal information request
 * @export
 * @interface ChangePlayerConsentsRequest
 */
export interface ChangePlayerConsentsRequest {
  /**
   *
   * @type {boolean}
   * @memberof ChangePlayerConsentsRequest
   */
  consentPhone: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ChangePlayerConsentsRequest
   */
  consentPostmail: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ChangePlayerConsentsRequest
   */
  consentPush: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ChangePlayerConsentsRequest
   */
  enableEmailSubscription: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ChangePlayerConsentsRequest
   */
  enableSmsSubscription: boolean;
}
/**
 *
 * @export
 * @interface CheckinSignupRequest
 */
export interface CheckinSignupRequest {
  /**
   *
   * @type {boolean}
   * @memberof CheckinSignupRequest
   */
  acceptEmailsOffer: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CheckinSignupRequest
   */
  acceptPrivacy: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CheckinSignupRequest
   */
  acceptSmsOffer: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CheckinSignupRequest
   */
  acceptTermsConditions: boolean;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  birthdate?: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  city: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  country: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  genderId: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  language: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  phonePrefix: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  postalCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  provinceCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  provinceName?: string | null;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  referrer: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof CheckinSignupRequest
   */
  userAgent: string;
}
/**
 *
 * @export
 * @interface CheckinValidationRequest
 */
export interface CheckinValidationRequest {
  /**
   *
   * @type {string}
   * @memberof CheckinValidationRequest
   */
  country?: string | null;
  /**
   *
   * @type {string}
   * @memberof CheckinValidationRequest
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof CheckinValidationRequest
   */
  displayName?: string | null;
  /**
   *
   * @type {string}
   * @memberof CheckinValidationRequest
   */
  email?: string | null;
  /**
   *
   * @type {string}
   * @memberof CheckinValidationRequest
   */
  siteId?: string;
}
/**
 *
 * @export
 * @interface ConfirmTokenRequest
 */
export interface ConfirmTokenRequest {
  /**
   *
   * @type {string}
   * @memberof ConfirmTokenRequest
   */
  registrationIP: string;
  /**
   *
   * @type {string}
   * @memberof ConfirmTokenRequest
   */
  token: string;
}
/**
 *
 * @export
 * @interface ConfirmTokenResponse
 */
export interface ConfirmTokenResponse {
  /**
   *
   * @type {string}
   * @memberof ConfirmTokenResponse
   */
  email: string;
}
/**
 *
 * @export
 * @interface ConfirmWithdrawRequest
 */
export interface ConfirmWithdrawRequest {
  /**
   *
   * @type {number}
   * @memberof ConfirmWithdrawRequest
   */
  withdrawId: number;
}
/**
 * Account represents a row from public.account
 * @export
 * @interface DBAccount
 */
export interface DBAccount {
  /**
   *
   * @type {boolean}
   * @memberof DBAccount
   */
  active: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBAccount
   */
  blocked: string;
  /**
   *
   * @type {string}
   * @memberof DBAccount
   */
  casinoBonus: string;
  /**
   *
   * @type {string}
   * @memberof DBAccount
   */
  casinoRestricted: string;
  /**
   *
   * @type {string}
   * @memberof DBAccount
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBAccount
   */
  currencyId: string;
  /**
   *
   * @type {number}
   * @memberof DBAccount
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBAccount
   */
  lastUpdatedAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBAccount
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBAccount
   */
  withdrawReserved: string;
  /**
   *
   * @type {string}
   * @memberof DBAccount
   */
  withdrawable: string;
}
/**
 * AccountTransaction represents a row from public.account_transaction
 * @export
 * @interface DBAccountTransaction
 */
export interface DBAccountTransaction {
  /**
   *
   * @type {number}
   * @memberof DBAccountTransaction
   */
  accountId: number;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransaction
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransaction
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransaction
   */
  fxRate: string;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransaction
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransaction
   */
  originalAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransaction
   */
  originalCurrencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransaction
   */
  playable: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransaction
   */
  playableBefore: string;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransaction
   */
  sourceId: number;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransaction
   */
  sourceTransactionId: number;
}
/**
 * AccountTransactionP201901 represents a row from public.account_transaction_p_2019_01
 * @export
 * @interface DBAccountTransactionP201901
 */
export interface DBAccountTransactionP201901 {
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionP201901
   */
  accountId: number;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP201901
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP201901
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP201901
   */
  fxRate: string;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionP201901
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP201901
   */
  originalAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP201901
   */
  originalCurrencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP201901
   */
  playable: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP201901
   */
  playableBefore: string;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionP201901
   */
  sourceId: number;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionP201901
   */
  sourceTransactionId: number;
}
/**
 * AccountTransactionP202001 represents a row from public.account_transaction_p_2020_01
 * @export
 * @interface DBAccountTransactionP202001
 */
export interface DBAccountTransactionP202001 {
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionP202001
   */
  accountId: number;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP202001
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP202001
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP202001
   */
  fxRate: string;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionP202001
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP202001
   */
  originalAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP202001
   */
  originalCurrencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP202001
   */
  playable: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionP202001
   */
  playableBefore: string;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionP202001
   */
  sourceId: number;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionP202001
   */
  sourceTransactionId: number;
}
/**
 * AccountTransactionPDefault represents a row from public.account_transaction_p_default
 * @export
 * @interface DBAccountTransactionPDefault
 */
export interface DBAccountTransactionPDefault {
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionPDefault
   */
  accountId: number;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionPDefault
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionPDefault
   */
  fxRate: string;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionPDefault
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionPDefault
   */
  originalAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionPDefault
   */
  originalCurrencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionPDefault
   */
  playable: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionPDefault
   */
  playableBefore: string;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionPDefault
   */
  sourceId: number;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionPDefault
   */
  sourceTransactionId: number;
}
/**
 * AccountTransactionSource represents a row from public.account_transaction_source
 * @export
 * @interface DBAccountTransactionSource
 */
export interface DBAccountTransactionSource {
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionSource
   */
  gameOperatorId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBAccountTransactionSource
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionSource
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionSource
   */
  paymentProviderId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionSource
   */
  sourceType: string;
}
/**
 * AccountTransactionSourceType represents a row from public.account_transaction_source_type
 * @export
 * @interface DBAccountTransactionSourceType
 */
export interface DBAccountTransactionSourceType {
  /**
   *
   * @type {string}
   * @memberof DBAccountTransactionSourceType
   */
  id: string;
}
/**
 * ActivePromotion represents a row from public.active_promotions
 * @export
 * @interface DBActivePromotion
 */
export interface DBActivePromotion {
  /**
   *
   * @type {string}
   * @memberof DBActivePromotion
   */
  bonusName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBActivePromotion
   */
  currencyId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBActivePromotion
   */
  depositMinAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBActivePromotion
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBActivePromotion
   */
  siteId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBActivePromotion
   */
  storyblokId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBActivePromotion
   */
  triggerDescription?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBActivePromotion
   */
  triggerName?: string | null;
}
/**
 * Bonus represents a row from public.bonus
 * @export
 * @interface DBBonus
 */
export interface DBBonus {
  /**
   *
   * @type {string}
   * @memberof DBBonus
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  depositNumber?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBBonus
   */
  endsAt: string;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  expiresInDays: number;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBBonus
   */
  isRecurrent: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  maxReceivedCount?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  maxReceivedResetInDays: number;
  /**
   *
   * @type {string}
   * @memberof DBBonus
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  percent: number;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  productTypeId: number;
  /**
   *
   * @type {string}
   * @memberof DBBonus
   */
  startsAt: string;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  statusId: number;
  /**
   *
   * @type {string}
   * @memberof DBBonus
   */
  storyblokId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  triggerTypeId: number;
  /**
   *
   * @type {string}
   * @memberof DBBonus
   */
  type: string;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  utcOffset: number;
  /**
   *
   * @type {number}
   * @memberof DBBonus
   */
  wagerMultiplier?: number | null;
}
/**
 * BonusCategorySetting represents a row from public.bonus_category_settings
 * @export
 * @interface DBBonusCategorySetting
 */
export interface DBBonusCategorySetting {
  /**
   *
   * @type {number}
   * @memberof DBBonusCategorySetting
   */
  bonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBBonusCategorySetting
   */
  categoryId: string;
  /**
   *
   * @type {number}
   * @memberof DBBonusCategorySetting
   */
  contributionPercentage: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusCategorySetting
   */
  id?: number | null;
}
/**
 * BonusCompletionSegment represents a row from public.bonus_completion_segment
 * @export
 * @interface DBBonusCompletionSegment
 */
export interface DBBonusCompletionSegment {
  /**
   *
   * @type {number}
   * @memberof DBBonusCompletionSegment
   */
  bonusId: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusCompletionSegment
   */
  completionRatio?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBBonusCompletionSegment
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBBonusCompletionSegment
   */
  segmentId: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusCompletionSegment
   */
  statusId: number;
}
/**
 * BonusConditionType represents a row from public.bonus_condition_type
 * @export
 * @interface DBBonusConditionType
 */
export interface DBBonusConditionType {
  /**
   *
   * @type {string}
   * @memberof DBBonusConditionType
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof DBBonusConditionType
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBBonusConditionType
   */
  name: string;
}
/**
 * BonusCurrencySetting represents a row from public.bonus_currency_settings
 * @export
 * @interface DBBonusCurrencySetting
 */
export interface DBBonusCurrencySetting {
  /**
   *
   * @type {string}
   * @memberof DBBonusCurrencySetting
   */
  autoforfeitMaxAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBBonusCurrencySetting
   */
  awardMaxAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBBonusCurrencySetting
   */
  betMaxAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBBonusCurrencySetting
   */
  bonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBBonusCurrencySetting
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBBonusCurrencySetting
   */
  depositMinAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBBonusCurrencySetting
   */
  id?: number | null;
}
/**
 * BonusFreespin represents a row from public.bonus_freespin
 * @export
 * @interface DBBonusFreespin
 */
export interface DBBonusFreespin {
  /**
   *
   * @type {number}
   * @memberof DBBonusFreespin
   */
  bonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBBonusFreespin
   */
  countryId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBBonusFreespin
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBBonusFreespin
   */
  denomination: string;
  /**
   *
   * @type {string}
   * @memberof DBBonusFreespin
   */
  extra1?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBBonusFreespin
   */
  extra2?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBBonusFreespin
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusFreespin
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBBonusFreespin
   */
  operatorId: string;
  /**
   *
   * @type {number}
   * @memberof DBBonusFreespin
   */
  priority: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusFreespin
   */
  quantity: number;
  /**
   *
   * @type {string}
   * @memberof DBBonusFreespin
   */
  rewardType: string;
}
/**
 * BonusFreespinRewardType represents a row from public.bonus_freespin_reward_type
 * @export
 * @interface DBBonusFreespinRewardType
 */
export interface DBBonusFreespinRewardType {
  /**
   *
   * @type {string}
   * @memberof DBBonusFreespinRewardType
   */
  id: string;
}
/**
 * BonusGame represents a row from public.bonus_game
 * @export
 * @interface DBBonusGame
 */
export interface DBBonusGame {
  /**
   *
   * @type {number}
   * @memberof DBBonusGame
   */
  bonusId: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusGame
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusGame
   */
  id?: number | null;
}
/**
 * BonusRewardType represents a row from public.bonus_reward_type
 * @export
 * @interface DBBonusRewardType
 */
export interface DBBonusRewardType {
  /**
   *
   * @type {string}
   * @memberof DBBonusRewardType
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof DBBonusRewardType
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof DBBonusRewardType
   */
  productTypeId: number;
}
/**
 * BonusSegment represents a row from public.bonus_segment
 * @export
 * @interface DBBonusSegment
 */
export interface DBBonusSegment {
  /**
   *
   * @type {number}
   * @memberof DBBonusSegment
   */
  bonusId: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusSegment
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBBonusSegment
   */
  segmentId: number;
}
/**
 * BonusSite represents a row from public.bonus_site
 * @export
 * @interface DBBonusSite
 */
export interface DBBonusSite {
  /**
   *
   * @type {number}
   * @memberof DBBonusSite
   */
  bonusId: number;
  /**
   *
   * @type {number}
   * @memberof DBBonusSite
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBBonusSite
   */
  siteId: string;
}
/**
 * BonusStatus represents a row from public.bonus_status
 * @export
 * @interface DBBonusStatus
 */
export interface DBBonusStatus {
  /**
   *
   * @type {string}
   * @memberof DBBonusStatus
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof DBBonusStatus
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBBonusStatus
   */
  name: string;
}
/**
 * BonusTriggerType represents a row from public.bonus_trigger_type
 * @export
 * @interface DBBonusTriggerType
 */
export interface DBBonusTriggerType {
  /**
   *
   * @type {string}
   * @memberof DBBonusTriggerType
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof DBBonusTriggerType
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBBonusTriggerType
   */
  name: string;
}
/**
 * CasinoGameCategory represents a row from public.casino_game_category
 * @export
 * @interface DBCasinoGameCategory
 */
export interface DBCasinoGameCategory {
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameCategory
   */
  categoryId: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameCategory
   */
  gameId: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoGameCategory
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameCategory
   */
  operatorId: string;
}
/**
 * CasinoGameDevice represents a row from public.casino_game_device
 * @export
 * @interface DBCasinoGameDevice
 */
export interface DBCasinoGameDevice {
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameDevice
   */
  deviceId: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameDevice
   */
  gameId: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoGameDevice
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameDevice
   */
  operatorId: string;
}
/**
 * CasinoGameProvider represents a row from public.casino_game_provider
 * @export
 * @interface DBCasinoGameProvider
 */
export interface DBCasinoGameProvider {
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameProvider
   */
  gameId: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameProvider
   */
  gameProviderId: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoGameProvider
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBCasinoGameProvider
   */
  operatorId: string;
}
/**
 * CasinoIncompleteRound represents a row from public.casino_incomplete_round
 * @export
 * @interface DBCasinoIncompleteRound
 */
export interface DBCasinoIncompleteRound {
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRound
   */
  accountId: number;
  /**
   *
   * @type {boolean}
   * @memberof DBCasinoIncompleteRound
   */
  completed: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBCasinoIncompleteRound
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRound
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRound
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRound
   */
  playerBonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBCasinoIncompleteRound
   */
  roundId: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRound
   */
  sourceId: number;
}
/**
 * CasinoIncompleteRoundPDefault represents a row from public.casino_incomplete_round_p_default
 * @export
 * @interface DBCasinoIncompleteRoundPDefault
 */
export interface DBCasinoIncompleteRoundPDefault {
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRoundPDefault
   */
  accountId: number;
  /**
   *
   * @type {boolean}
   * @memberof DBCasinoIncompleteRoundPDefault
   */
  completed: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBCasinoIncompleteRoundPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRoundPDefault
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRoundPDefault
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRoundPDefault
   */
  playerBonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBCasinoIncompleteRoundPDefault
   */
  roundId: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoIncompleteRoundPDefault
   */
  sourceId: number;
}
/**
 * CasinoPlayerBonus represents a row from public.casino_player_bonus
 * @export
 * @interface DBCasinoPlayerBonus
 */
export interface DBCasinoPlayerBonus {
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  bonus: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  cancelledAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  convertedAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  expiredAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  forfeitedAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoPlayerBonus
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  initialBonus: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  initialRestricted: string;
  /**
   *
   * @type {number}
   * @memberof DBCasinoPlayerBonus
   */
  playerBonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  restrictedAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  wagerRequiredAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBCasinoPlayerBonus
   */
  wagerTotalAmount: string;
}
/**
 * Category represents a row from public.category
 * @export
 * @interface DBCategory
 */
export interface DBCategory {
  /**
   *
   * @type {string}
   * @memberof DBCategory
   */
  id: string;
}
/**
 * CheckinPlayerProfile represents a row from public.checkin_player_profile
 * @export
 * @interface DBCheckinPlayerProfile
 */
export interface DBCheckinPlayerProfile {
  /**
   *
   * @type {boolean}
   * @memberof DBCheckinPlayerProfile
   */
  acceptEmailsOffer: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBCheckinPlayerProfile
   */
  acceptPrivacy: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBCheckinPlayerProfile
   */
  acceptSmsOffer: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBCheckinPlayerProfile
   */
  acceptTermsConditions: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  birthdate: string;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  city: string;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  country: string;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  firstName: string;
  /**
   *
   * @type {number}
   * @memberof DBCheckinPlayerProfile
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  phoneNumber: string;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  phonePrefix: string;
  /**
   *
   * @type {number}
   * @memberof DBCheckinPlayerProfile
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  postalCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  provinceCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  provinceName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBCheckinPlayerProfile
   */
  siteId: string;
}
/**
 * Config represents a row from public.config
 * @export
 * @interface DBConfig
 */
export interface DBConfig {
  /**
   *
   * @type {string}
   * @memberof DBConfig
   */
  envName: string;
  /**
   *
   * @type {number}
   * @memberof DBConfig
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBConfig
   */
  jwtSecret: string;
  /**
   *
   * @type {string}
   * @memberof DBConfig
   */
  notificationsURLTemplate: string;
  /**
   *
   * @type {number}
   * @memberof DBConfig
   */
  sessionTTL: number;
  /**
   *
   * @type {string}
   * @memberof DBConfig
   */
  trafficSplitterURL: string;
}
/**
 * Country represents a row from public.country
 * @export
 * @interface DBCountry
 */
export interface DBCountry {
  /**
   *
   * @type {string}
   * @memberof DBCountry
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBCountry
   */
  name?: string | null;
}
/**
 * Currency represents a row from public.currency
 * @export
 * @interface DBCurrency
 */
export interface DBCurrency {
  /**
   *
   * @type {string}
   * @memberof DBCurrency
   */
  comment: string;
  /**
   *
   * @type {string}
   * @memberof DBCurrency
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof DBCurrency
   */
  hub88Name: string;
  /**
   *
   * @type {string}
   * @memberof DBCurrency
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBCurrency
   */
  slotegratorName: string;
}
/**
 * CurrencyRate represents a row from public.currency_rate
 * @export
 * @interface DBCurrencyRate
 */
export interface DBCurrencyRate {
  /**
   *
   * @type {string}
   * @memberof DBCurrencyRate
   */
  dstCurrency: string;
  /**
   *
   * @type {string}
   * @memberof DBCurrencyRate
   */
  lastUpdatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBCurrencyRate
   */
  rate: string;
  /**
   *
   * @type {string}
   * @memberof DBCurrencyRate
   */
  srcCurrency: string;
}
/**
 * DbmateMigrationsReporting represents a row from public.dbmate_migrations_reporting
 * @export
 * @interface DBDbmateMigrationsReporting
 */
export interface DBDbmateMigrationsReporting {
  /**
   *
   * @type {string}
   * @memberof DBDbmateMigrationsReporting
   */
  version: string;
}
/**
 * Deposit represents a row from public.deposit
 * @export
 * @interface DBDeposit
 */
export interface DBDeposit {
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  amount: string;
  /**
   *
   * @type {number}
   * @memberof DBDeposit
   */
  bonusId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  currencyId: string;
  /**
   *
   * @type {number}
   * @memberof DBDeposit
   */
  depositNumber: number;
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  externalPlayerId: string;
  /**
   *
   * @type {number}
   * @memberof DBDeposit
   */
  externalTransactionId: number;
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  fundedAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBDeposit
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  notes: string;
  /**
   *
   * @type {number}
   * @memberof DBDeposit
   */
  paymentAccountId: number;
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  paymentProviderId: string;
  /**
   *
   * @type {number}
   * @memberof DBDeposit
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof DBDeposit
   */
  userId?: string | null;
}
/**
 * DBDepositCount
 * @export
 * @interface DBDepositCount
 */
export interface DBDepositCount {
  /**
   *
   * @type {number}
   * @memberof DBDepositCount
   */
  depositCount: number;
}
/**
 * DBDepositMaxNumber
 * @export
 * @interface DBDepositMaxNumber
 */
export interface DBDepositMaxNumber {
  /**
   *
   * @type {number}
   * @memberof DBDepositMaxNumber
   */
  maxNumber: number;
}
/**
 * DepositStatus represents a row from public.deposit_status
 * @export
 * @interface DBDepositStatus
 */
export interface DBDepositStatus {
  /**
   *
   * @type {string}
   * @memberof DBDepositStatus
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof DBDepositStatus
   */
  id: string;
}
/**
 * Device represents a row from public.device
 * @export
 * @interface DBDevice
 */
export interface DBDevice {
  /**
   *
   * @type {string}
   * @memberof DBDevice
   */
  id: string;
}
/**
 * Document represents a row from public.document
 * @export
 * @interface DBDocument
 */
export interface DBDocument {
  /**
   *
   * @type {string}
   * @memberof DBDocument
   */
  createdAt?: string;
  /**
   *
   * @type {boolean}
   * @memberof DBDocument
   */
  deleted: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBDocument
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBDocument
   */
  markedForDeletion: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBDocument
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof DBDocument
   */
  url: string;
}
/**
 * DocumentType represents a row from public.document_type
 * @export
 * @interface DBDocumentType
 */
export interface DBDocumentType {
  /**
   *
   * @type {string}
   * @memberof DBDocumentType
   */
  id: string;
}
/**
 * DummygamingAction represents a row from public.dummygaming_action
 * @export
 * @interface DBDummygamingAction
 */
export interface DBDummygamingAction {
  /**
   *
   * @type {string}
   * @memberof DBDummygamingAction
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof DBDummygamingAction
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBDummygamingAction
   */
  externalId: string;
  /**
   *
   * @type {string}
   * @memberof DBDummygamingAction
   */
  game: string;
  /**
   *
   * @type {number}
   * @memberof DBDummygamingAction
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBDummygamingAction
   */
  round: string;
  /**
   *
   * @type {string}
   * @memberof DBDummygamingAction
   */
  sessionToken: string;
}
/**
 * DummygamingToken represents a row from public.dummygaming_token
 * @export
 * @interface DBDummygamingToken
 */
export interface DBDummygamingToken {
  /**
   *
   * @type {string}
   * @memberof DBDummygamingToken
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBDummygamingToken
   */
  expiresAt: string;
  /**
   *
   * @type {number}
   * @memberof DBDummygamingToken
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBDummygamingToken
   */
  playerId: number;
  /**
   *
   * @type {number}
   * @memberof DBDummygamingToken
   */
  siteSessionId: number;
  /**
   *
   * @type {string}
   * @memberof DBDummygamingToken
   */
  token: string;
}
/**
 * FavouriteGame represents a row from public.favourite_games
 * @export
 * @interface DBFavouriteGame
 */
export interface DBFavouriteGame {
  /**
   *
   * @type {string}
   * @memberof DBFavouriteGame
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBFavouriteGame
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof DBFavouriteGame
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBFavouriteGame
   */
  playerId: number;
}
/**
 * Game represents a row from public.game
 * @export
 * @interface DBGame
 */
export interface DBGame {
  /**
   *
   * @type {string}
   * @memberof DBGame
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof DBGame
   */
  externalGameId: string;
  /**
   *
   * @type {boolean}
   * @memberof DBGame
   */
  hasFreespins: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBGame
   */
  href: string;
  /**
   *
   * @type {number}
   * @memberof DBGame
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBGame
   */
  isActive: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBGame
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof DBGame
   */
  operatorId: string;
  /**
   *
   * @type {string}
   * @memberof DBGame
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBGame
   */
  slug: string;
}
/**
 * GameCategory represents a row from public.game_category
 * @export
 * @interface DBGameCategory
 */
export interface DBGameCategory {
  /**
   *
   * @type {string}
   * @memberof DBGameCategory
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof DBGameCategory
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBGameCategory
   */
  isActive: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBGameCategory
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof DBGameCategory
   */
  parentCategoryId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBGameCategory
   */
  slug: string;
}
/**
 * GameMenuItem represents a row from public.game_menu_item
 * @export
 * @interface DBGameMenuItem
 */
export interface DBGameMenuItem {
  /**
   *
   * @type {string}
   * @memberof DBGameMenuItem
   */
  handle: string;
  /**
   *
   * @type {number}
   * @memberof DBGameMenuItem
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBGameMenuItem
   */
  name: string;
}
/**
 * GameMetadatum represents a row from public.game_metadata
 * @export
 * @interface DBGameMetadatum
 */
export interface DBGameMetadatum {
  /**
   *
   * @type {string}
   * @memberof DBGameMetadatum
   */
  backgroundURL?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBGameMetadatum
   */
  gameId: number;
  /**
   *
   * @type {string}
   * @memberof DBGameMetadatum
   */
  gameType: string;
  /**
   *
   * @type {boolean}
   * @memberof DBGameMetadatum
   */
  hasInGameLobby: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBGameMetadatum
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBGameMetadatum
   */
  isFavourite: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBGameMetadatum
   */
  isFeatured: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBGameMetadatum
   */
  isHot: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBGameMetadatum
   */
  isInLoyalty: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBGameMetadatum
   */
  isMobileSupported: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBGameMetadatum
   */
  isNew: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBGameMetadatum
   */
  maxBet: string;
  /**
   *
   * @type {number}
   * @memberof DBGameMetadatum
   */
  menuItemId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBGameMetadatum
   */
  minBet: string;
  /**
   *
   * @type {string}
   * @memberof DBGameMetadatum
   */
  rtp: string;
  /**
   *
   * @type {string}
   * @memberof DBGameMetadatum
   */
  thumbnailURL: string;
}
/**
 * GameOperator represents a row from public.game_operator
 * @export
 * @interface DBGameOperator
 */
export interface DBGameOperator {
  /**
   *
   * @type {string}
   * @memberof DBGameOperator
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof DBGameOperator
   */
  id: string;
}
/**
 * GameOperatorProvider represents a row from public.game_operator_provider
 * @export
 * @interface DBGameOperatorProvider
 */
export interface DBGameOperatorProvider {
  /**
   *
   * @type {string}
   * @memberof DBGameOperatorProvider
   */
  id: string;
}
/**
 * GameSetting represents a row from public.game_settings
 * @export
 * @interface DBGameSetting
 */
export interface DBGameSetting {
  /**
   *
   * @type {boolean}
   * @memberof DBGameSetting
   */
  allowBonusBets: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBGameSetting
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBGameSetting
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof DBGameSetting
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBGameSetting
   */
  lastUpdatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBGameSetting
   */
  siteId: string;
  /**
   *
   * @type {number}
   * @memberof DBGameSetting
   */
  wageringRequirementContributionPercent: number;
}
/**
 * GameToGameCategory represents a row from public.game_to_game_category
 * @export
 * @interface DBGameToGameCategory
 */
export interface DBGameToGameCategory {
  /**
   *
   * @type {number}
   * @memberof DBGameToGameCategory
   */
  gameCategoryId: number;
  /**
   *
   * @type {number}
   * @memberof DBGameToGameCategory
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof DBGameToGameCategory
   */
  id?: number | null;
}
/**
 * Gender represents a row from public.gender
 * @export
 * @interface DBGender
 */
export interface DBGender {
  /**
   *
   * @type {string}
   * @memberof DBGender
   */
  id: string;
}
/**
 * KafkaEventsQueue represents a row from public.kafka_events_queue
 * @export
 * @interface DBKafkaEventsQueue
 */
export interface DBKafkaEventsQueue {
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  headerApplication: string;
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  headerCorrelationId: string;
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  headerMessageId: string;
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  headerTimestamp: string;
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  headerType: string;
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  headerVersion: string;
  /**
   *
   * @type {number}
   * @memberof DBKafkaEventsQueue
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  partitionShardingKey: string;
  /**
   *
   * @type {object}
   * @memberof DBKafkaEventsQueue
   */
  payload: object;
  /**
   *
   * @type {string}
   * @memberof DBKafkaEventsQueue
   */
  topic: string;
}
/**
 * KycApplicationStatus represents a row from public.kyc_application_status
 * @export
 * @interface DBKycApplicationStatus
 */
export interface DBKycApplicationStatus {
  /**
   *
   * @type {string}
   * @memberof DBKycApplicationStatus
   */
  id: string;
}
/**
 * KycProvider represents a row from public.kyc_provider
 * @export
 * @interface DBKycProvider
 */
export interface DBKycProvider {
  /**
   *
   * @type {string}
   * @memberof DBKycProvider
   */
  displayName?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBKycProvider
   */
  id: number;
}
/**
 * KycStatus represents a row from public.kyc_status
 * @export
 * @interface DBKycStatus
 */
export interface DBKycStatus {
  /**
   *
   * @type {string}
   * @memberof DBKycStatus
   */
  displayName?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBKycStatus
   */
  id: number;
}
/**
 * Language represents a row from public.language
 * @export
 * @interface DBLanguage
 */
export interface DBLanguage {
  /**
   *
   * @type {string}
   * @memberof DBLanguage
   */
  id: string;
}
/**
 * LobbyGame represents a row from public.lobby_games
 * @export
 * @interface DBLobbyGame
 */
export interface DBLobbyGame {
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  backgroundURL?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  description?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  externalGameId?: string | null;
  /**
   *
   * @type {Array<number>}
   * @memberof DBLobbyGame
   */
  gameCategoriesIds: Array<number>;
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  href?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBLobbyGame
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  name?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  operatorHandle?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  providerHandle?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  slug?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBLobbyGame
   */
  thumbnailURL?: string | null;
}
/**
 * Locale represents a row from public.locale
 * @export
 * @interface DBLocale
 */
export interface DBLocale {
  /**
   *
   * @type {string}
   * @memberof DBLocale
   */
  id: string;
}
/**
 * NotificationEvent represents a row from public.notification_event
 * @export
 * @interface DBNotificationEvent
 */
export interface DBNotificationEvent {
  /**
   *
   * @type {string}
   * @memberof DBNotificationEvent
   */
  displayName: string;
  /**
   *
   * @type {number}
   * @memberof DBNotificationEvent
   */
  id?: number | null;
}
/**
 * NotificationSetting represents a row from public.notification_settings
 * @export
 * @interface DBNotificationSetting
 */
export interface DBNotificationSetting {
  /**
   *
   * @type {string}
   * @memberof DBNotificationSetting
   */
  emailSender: string;
  /**
   *
   * @type {number}
   * @memberof DBNotificationSetting
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBNotificationSetting
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof DBNotificationSetting
   */
  smsSender: string;
}
/**
 * NotificationTemplateSetting represents a row from public.notification_template_settings
 * @export
 * @interface DBNotificationTemplateSetting
 */
export interface DBNotificationTemplateSetting {
  /**
   *
   * @type {boolean}
   * @memberof DBNotificationTemplateSetting
   */
  emailEnabled: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBNotificationTemplateSetting
   */
  eventId: number;
  /**
   *
   * @type {number}
   * @memberof DBNotificationTemplateSetting
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBNotificationTemplateSetting
   */
  languageId: string;
  /**
   *
   * @type {number}
   * @memberof DBNotificationTemplateSetting
   */
  settingId: number;
  /**
   *
   * @type {boolean}
   * @memberof DBNotificationTemplateSetting
   */
  smsEnabled: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBNotificationTemplateSetting
   */
  smsTemplate: string;
  /**
   *
   * @type {string}
   * @memberof DBNotificationTemplateSetting
   */
  subject: string;
  /**
   *
   * @type {string}
   * @memberof DBNotificationTemplateSetting
   */
  template: string;
}
/**
 * PaymentCard represents a row from public.payment_card
 * @export
 * @interface DBPaymentCard
 */
export interface DBPaymentCard {
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  cardHolder: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  expiryMonth: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  expiryYear: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  externalAccountId: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  externalPaymentProvider: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentCard
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  lastUpdatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  maskedAccount: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  paymentProviderId: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  playerExternalId: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentCard
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCard
   */
  schema: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentCard
   */
  stateId: number;
}
/**
 * PaymentCardState represents a row from public.payment_card_state
 * @export
 * @interface DBPaymentCardState
 */
export interface DBPaymentCardState {
  /**
   *
   * @type {string}
   * @memberof DBPaymentCardState
   */
  displayName?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPaymentCardState
   */
  id?: number | null;
}
/**
 * PaymentCategory represents a row from public.payment_category
 * @export
 * @interface DBPaymentCategory
 */
export interface DBPaymentCategory {
  /**
   *
   * @type {number}
   * @memberof DBPaymentCategory
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentCategory
   */
  name: string;
}
/**
 * PaymentHistory represents a row from public.payment_history
 * @export
 * @interface DBPaymentHistory
 */
export interface DBPaymentHistory {
  /**
   *
   * @type {string}
   * @memberof DBPaymentHistory
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentHistory
   */
  createdAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentHistory
   */
  currencyId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentHistory
   */
  paymentType?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPaymentHistory
   */
  playerId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentHistory
   */
  providerId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentHistory
   */
  status?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentHistory
   */
  updatedAt?: string | null;
}
/**
 * PaymentLimitType represents a row from public.payment_limit_type
 * @export
 * @interface DBPaymentLimitType
 */
export interface DBPaymentLimitType {
  /**
   *
   * @type {string}
   * @memberof DBPaymentLimitType
   */
  displayName?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPaymentLimitType
   */
  id?: number | null;
}
/**
 * PaymentProvider represents a row from public.payment_provider
 * @export
 * @interface DBPaymentProvider
 */
export interface DBPaymentProvider {
  /**
   *
   * @type {string}
   * @memberof DBPaymentProvider
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentProvider
   */
  id: string;
}
/**
 * PaymentiqConfig represents a row from public.paymentiq_config
 * @export
 * @interface DBPaymentiqConfig
 */
export interface DBPaymentiqConfig {
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqConfig
   */
  apiToken: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqConfig
   */
  apiURL: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqConfig
   */
  cancelURL: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqConfig
   */
  failureURL: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqConfig
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqConfig
   */
  merchantId: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqConfig
   */
  pendingURL: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqConfig
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqConfig
   */
  successURL: string;
}
/**
 * PaymentiqStatus represents a row from public.paymentiq_status
 * @export
 * @interface DBPaymentiqStatus
 */
export interface DBPaymentiqStatus {
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqStatus
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqStatus
   */
  status: string;
}
/**
 * PaymentiqTransaction represents a row from public.paymentiq_transaction
 * @export
 * @interface DBPaymentiqTransaction
 */
export interface DBPaymentiqTransaction {
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  amount: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqTransaction
   */
  bonusId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  externalId: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqTransaction
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqTransaction
   */
  internalTransactionId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  lastUpdatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  operatorRefId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqTransaction
   */
  operatorTxId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  operatorTxType: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqTransaction
   */
  paymentCardId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  paymentProviderId: string;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  playerExternalId: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqTransaction
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  provider?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPaymentiqTransaction
   */
  siteId: string;
  /**
   *
   * @type {number}
   * @memberof DBPaymentiqTransaction
   */
  status: number;
}
/**
 * Permission represents a row from public.permission
 * @export
 * @interface DBPermission
 */
export interface DBPermission {
  /**
   *
   * @type {string}
   * @memberof DBPermission
   */
  id: string;
}
/**
 * Player represents a row from public.player
 * @export
 * @interface DBPlayer
 */
export interface DBPlayer {
  /**
   *
   * @type {boolean}
   * @memberof DBPlayer
   */
  acceptsBonuses: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  affiliateReferenceCode?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayer
   */
  agreementAccepted: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  baseCurrencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  city?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayer
   */
  consentPhone: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayer
   */
  consentPostmail: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayer
   */
  consentPush: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  countryId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  dateOfBirth?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  displayName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  externalId: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayer
   */
  failedLoginAttempts: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  firstName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  genderId: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayer
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  languageId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  lastName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  loginAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  loginIP?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  origin: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  phoneNumber?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  phonePrefix?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  postalCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  privacyPolicyAcceptedDate: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  provinceCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  provinceName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  referrer: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  registrationIP: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  registrationUserAgent: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  street?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayer
   */
  subscriptionEmailEnabled: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayer
   */
  subscriptionSmsEnabled: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayer
   */
  unsubscribeToken: string;
}
/**
 * PlayerActiveCard represents a row from public.player_active_cards
 * @export
 * @interface DBPlayerActiveCard
 */
export interface DBPlayerActiveCard {
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCard
   */
  cardHolder?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCard
   */
  currencyId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCard
   */
  expiryMonth?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCard
   */
  expiryYear?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCard
   */
  externalAccountId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCard
   */
  maskedAccount?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCard
   */
  paymentProviderId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerActiveCard
   */
  playerId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCard
   */
  schema?: string | null;
}
/**
 * DBPlayerActiveCasinoBonuses
 * @export
 * @interface DBPlayerActiveCasinoBonuses
 */
export interface DBPlayerActiveCasinoBonuses {
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  bonus: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  bonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  bonusName: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  bonusStatus: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  cancelledAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  convertedAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  endsAt: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  expiredAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  forfeitedAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  initialBonus: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  initialRestricted: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  playerBonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  restrictedAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  storyblokId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  wagerRequiredAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerActiveCasinoBonuses
   */
  wagerTotalAmount: string;
}
/**
 * PlayerBalance represents a row from public.player_balance
 * @export
 * @interface DBPlayerBalance
 */
export interface DBPlayerBalance {
  /**
   *
   * @type {string}
   * @memberof DBPlayerBalance
   */
  currencyId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerBalance
   */
  playerId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBalance
   */
  totalAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBalance
   */
  totalBonusAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBalance
   */
  withdrawableAmount: string;
}
/**
 * PlayerBonus represents a row from public.player_bonus
 * @export
 * @interface DBPlayerBonus
 */
export interface DBPlayerBonus {
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonus
   */
  accountId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonus
   */
  bonusId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBonus
   */
  cancellationReason?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBonus
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonus
   */
  depositId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBonus
   */
  expiresAt: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBonus
   */
  finishedAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonus
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBonus
   */
  lastUpdatedAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonus
   */
  productTypeId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonus
   */
  statusId: number;
}
/**
 * DBPlayerBonusCount
 * @export
 * @interface DBPlayerBonusCount
 */
export interface DBPlayerBonusCount {
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonusCount
   */
  count: number;
}
/**
 * PlayerBonusPoint represents a row from public.player_bonus_points
 * @export
 * @interface DBPlayerBonusPoint
 */
export interface DBPlayerBonusPoint {
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonusPoint
   */
  playerId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBonusPoint
   */
  points: string;
}
/**
 * PlayerBonusStatus represents a row from public.player_bonus_status
 * @export
 * @interface DBPlayerBonusStatus
 */
export interface DBPlayerBonusStatus {
  /**
   *
   * @type {string}
   * @memberof DBPlayerBonusStatus
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerBonusStatus
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerBonusStatus
   */
  name: string;
}
/**
 * DBPlayerConsecutiveDays
 * @export
 * @interface DBPlayerConsecutiveDays
 */
export interface DBPlayerConsecutiveDays {
  /**
   *
   * @type {number}
   * @memberof DBPlayerConsecutiveDays
   */
  consecutiveDates: number;
}
/**
 * PlayerDeposit represents a row from public.player_deposit
 * @export
 * @interface DBPlayerDeposit
 */
export interface DBPlayerDeposit {
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  createdAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  currencyId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerDeposit
   */
  depositNumber?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  externalPlayerId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerDeposit
   */
  externalTransactionId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  firstName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  fundedAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerDeposit
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  lastName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  notes?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerDeposit
   */
  paymentAccountId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  paymentProviderId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerDeposit
   */
  playerId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  siteId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  status?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDeposit
   */
  userId?: string | null;
}
/**
 * PlayerDetail represents a row from public.player_details
 * @export
 * @interface DBPlayerDetail
 */
export interface DBPlayerDetail {
  /**
   *
   * @type {boolean}
   * @memberof DBPlayerDetail
   */
  acceptsBonuses: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  affiliateReferenceCode?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayerDetail
   */
  agreementAccepted: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  baseCurrencyId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  city?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayerDetail
   */
  consentPhone: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayerDetail
   */
  consentPostmail: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayerDetail
   */
  consentPush: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  countryId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  createdAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  dateOfBirth?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  displayName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  email?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  externalId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerDetail
   */
  failedLoginAttempts?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  firstName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  genderId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerDetail
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  languageId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  lastName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  loginAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  loginIP?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  origin?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  password?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  phoneNumber?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  phonePrefix?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof DBPlayerDetail
   */
  playerPermissions: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DBPlayerDetail
   */
  playerRules: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  postalCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  privacyPolicyAcceptedDate?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  provinceCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  provinceName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  referrer?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  registrationIP?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  registrationUserAgent?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  siteId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  street?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayerDetail
   */
  subscriptionEmailEnabled: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPlayerDetail
   */
  subscriptionSmsEnabled: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerDetail
   */
  unsubscribeToken: string;
}
/**
 * DBPlayerEligibleBonuses
 * @export
 * @interface DBPlayerEligibleBonuses
 */
export interface DBPlayerEligibleBonuses {
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  autoforfeitMaxAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  bonusName: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  currencyId: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  depositNumber: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  endsAt: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  expiresInDays: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  maxAwardAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  maxBetAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  maxReceivedCount: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  maxReceivedResetInDays: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  minDepositAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  productTypeId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  rewardPercent: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  rewardType: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  startsAt: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  storyblokId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  triggerDescription: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerEligibleBonuses
   */
  triggerName: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  triggerTypeId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  utcOffset: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerEligibleBonuses
   */
  wagerMultiplier: number;
}
/**
 * PlayerExchange represents a row from public.player_exchange
 * @export
 * @interface DBPlayerExchange
 */
export interface DBPlayerExchange {
  /**
   *
   * @type {number}
   * @memberof DBPlayerExchange
   */
  accountFrom: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerExchange
   */
  accountTo: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerExchange
   */
  amountFrom: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerExchange
   */
  amountTo: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerExchange
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerExchange
   */
  currencyFrom: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerExchange
   */
  currencyTo: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerExchange
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerExchange
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerExchange
   */
  rate: string;
}
/**
 * PlayerFavouriteGame represents a row from public.player_favourite_game
 * @export
 * @interface DBPlayerFavouriteGame
 */
export interface DBPlayerFavouriteGame {
  /**
   *
   * @type {string}
   * @memberof DBPlayerFavouriteGame
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFavouriteGame
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFavouriteGame
   */
  playerId: number;
}
/**
 * PlayerFreespin represents a row from public.player_freespin
 * @export
 * @interface DBPlayerFreespin
 */
export interface DBPlayerFreespin {
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespin
   */
  bonusFreespinId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespin
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespin
   */
  expiresAt: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespin
   */
  freespinExternalId: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespin
   */
  freespinId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespin
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespin
   */
  operatorId: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespin
   */
  playerBonusId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespin
   */
  playerRewardBonusId?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespin
   */
  priority: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespin
   */
  statusId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespin
   */
  totalWinAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespin
   */
  winExternalTransactionId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespin
   */
  winReceivedAt?: string | null;
}
/**
 * PlayerFreespinPDefault represents a row from public.player_freespin_p_default
 * @export
 * @interface DBPlayerFreespinPDefault
 */
export interface DBPlayerFreespinPDefault {
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespinPDefault
   */
  bonusFreespinId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespinPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespinPDefault
   */
  expiresAt: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespinPDefault
   */
  freespinExternalId: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespinPDefault
   */
  freespinId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespinPDefault
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespinPDefault
   */
  operatorId: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespinPDefault
   */
  playerBonusId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespinPDefault
   */
  playerRewardBonusId?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespinPDefault
   */
  priority: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespinPDefault
   */
  statusId: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespinPDefault
   */
  totalWinAmount: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerFreespinPDefault
   */
  winExternalTransactionId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespinPDefault
   */
  winReceivedAt?: string | null;
}
/**
 * PlayerFreespinStatus represents a row from public.player_freespin_status
 * @export
 * @interface DBPlayerFreespinStatus
 */
export interface DBPlayerFreespinStatus {
  /**
   *
   * @type {string}
   * @memberof DBPlayerFreespinStatus
   */
  id: string;
}
/**
 * DBPlayerGameHistory
 * @export
 * @interface DBPlayerGameHistory
 */
export interface DBPlayerGameHistory {
  /**
   *
   * @type {string}
   * @memberof DBPlayerGameHistory
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerGameHistory
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerGameHistory
   */
  gameName: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerGameHistory
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerGameHistory
   */
  sourceType: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerGameHistory
   */
  txid: number;
}
/**
 * PlayerKycApplication represents a row from public.player_kyc_application
 * @export
 * @interface DBPlayerKycApplication
 */
export interface DBPlayerKycApplication {
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycApplication
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycApplication
   */
  documentType: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycApplication
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycApplication
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycApplication
   */
  status: string;
}
/**
 * PlayerKycApplicationDocument represents a row from public.player_kyc_application_document
 * @export
 * @interface DBPlayerKycApplicationDocument
 */
export interface DBPlayerKycApplicationDocument {
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycApplicationDocument
   */
  applicationId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycApplicationDocument
   */
  approvedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycApplicationDocument
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycApplicationDocument
   */
  documentId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycApplicationDocument
   */
  expiresAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycApplicationDocument
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycApplicationDocument
   */
  rejectedAt?: string | null;
}
/**
 * PlayerKycInfo represents a row from public.player_kyc_info
 * @export
 * @interface DBPlayerKycInfo
 */
export interface DBPlayerKycInfo {
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycInfo
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycInfo
   */
  expiresAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycInfo
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycInfo
   */
  kycProviderId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycInfo
   */
  kycStatusId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycInfo
   */
  lastUpdatedAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerKycInfo
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerKycInfo
   */
  reason?: string | null;
}
/**
 * PlayerPermission represents a row from public.player_permission
 * @export
 * @interface DBPlayerPermission
 */
export interface DBPlayerPermission {
  /**
   *
   * @type {number}
   * @memberof DBPlayerPermission
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerPermission
   */
  permissionId: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerPermission
   */
  playerId: number;
}
/**
 * PlayerRule represents a row from public.player_rule
 * @export
 * @interface DBPlayerRule
 */
export interface DBPlayerRule {
  /**
   *
   * @type {string}
   * @memberof DBPlayerRule
   */
  expiresAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerRule
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerRule
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerRule
   */
  ruleId: string;
}
/**
 * PlayerRuleHistory represents a row from public.player_rule_history
 * @export
 * @interface DBPlayerRuleHistory
 */
export interface DBPlayerRuleHistory {
  /**
   *
   * @type {boolean}
   * @memberof DBPlayerRuleHistory
   */
  added: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerRuleHistory
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerRuleHistory
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerRuleHistory
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerRuleHistory
   */
  ruleId: string;
}
/**
 * PlayerSegment represents a row from public.player_segment
 * @export
 * @interface DBPlayerSegment
 */
export interface DBPlayerSegment {
  /**
   *
   * @type {number}
   * @memberof DBPlayerSegment
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerSegment
   */
  playerId: number;
  /**
   *
   * @type {number}
   * @memberof DBPlayerSegment
   */
  segmentId: number;
}
/**
 * PlayerToken represents a row from public.player_token
 * @export
 * @interface DBPlayerToken
 */
export interface DBPlayerToken {
  /**
   *
   * @type {string}
   * @memberof DBPlayerToken
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerToken
   */
  expiresAt: string;
  /**
   *
   * @type {number}
   * @memberof DBPlayerToken
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerToken
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBPlayerToken
   */
  token: string;
}
/**
 * PlayerWithdraw represents a row from public.player_withdraw
 * @export
 * @interface DBPlayerWithdraw
 */
export interface DBPlayerWithdraw {
  /**
   *
   * @type {number}
   * @memberof DBPlayerWithdraw
   */
  accountId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  address?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  approvedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  approvedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  cancelledAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  confirmedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  createdAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  currencyId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  executedAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerWithdraw
   */
  externalTransactionId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  faultedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  firstName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  frozenAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  frozenByUserId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerWithdraw
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  languageId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  lastName?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  paymentProviderId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  paymentServiceError?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBPlayerWithdraw
   */
  playerId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  reason?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  rejectedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  rejectedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  retriedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  retriedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  siteId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPlayerWithdraw
   */
  status?: string | null;
}
/**
 * DBPlayerreportsFasttrack
 * @export
 * @interface DBPlayerreportsFasttrack
 */
export interface DBPlayerreportsFasttrack {
  /**
   *
   * @type {string}
   * @memberof DBPlayerreportsFasttrack
   */
  externalId: string;
}
/**
 * PragmaticAction represents a row from public.pragmatic_action
 * @export
 * @interface DBPragmaticAction
 */
export interface DBPragmaticAction {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  bonusCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  externalGameId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  externalPlayerId: string;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticAction
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  pragmaticSessionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  rounddetails?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  roundid: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  transactionReference: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticAction
   */
  type: string;
}
/**
 * PragmaticActionP202201 represents a row from public.pragmatic_action_p_2022_01
 * @export
 * @interface DBPragmaticActionP202201
 */
export interface DBPragmaticActionP202201 {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  bonusCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  externalGameId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  externalPlayerId: string;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticActionP202201
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  pragmaticSessionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  rounddetails?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  roundid: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  transactionReference: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202201
   */
  type: string;
}
/**
 * PragmaticActionP202301 represents a row from public.pragmatic_action_p_2023_01
 * @export
 * @interface DBPragmaticActionP202301
 */
export interface DBPragmaticActionP202301 {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  bonusCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  externalGameId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  externalPlayerId: string;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticActionP202301
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  pragmaticSessionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  rounddetails?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  roundid: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  transactionReference: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionP202301
   */
  type: string;
}
/**
 * PragmaticActionPDefault represents a row from public.pragmatic_action_p_default
 * @export
 * @interface DBPragmaticActionPDefault
 */
export interface DBPragmaticActionPDefault {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  bonusCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  externalGameId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  externalPlayerId: string;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticActionPDefault
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  pragmaticSessionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  rounddetails?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  roundid: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  transactionReference: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticActionPDefault
   */
  type: string;
}
/**
 * PragmaticFreespin represents a row from public.pragmatic_freespin
 * @export
 * @interface DBPragmaticFreespin
 */
export interface DBPragmaticFreespin {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  errorCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  errorDescription?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  externalGameId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  freespinId: string;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticFreespin
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBPragmaticFreespin
   */
  isCanceled: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticFreespin
   */
  playerId: number;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticFreespin
   */
  rounds: number;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  totalbet: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  validFrom: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespin
   */
  validUntil: string;
}
/**
 * PragmaticFreespinPDefault represents a row from public.pragmatic_freespin_p_default
 * @export
 * @interface DBPragmaticFreespinPDefault
 */
export interface DBPragmaticFreespinPDefault {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  errorCode?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  errorDescription?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  externalGameId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  freespinId: string;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticFreespinPDefault
   */
  id: number;
  /**
   *
   * @type {boolean}
   * @memberof DBPragmaticFreespinPDefault
   */
  isCanceled: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticFreespinPDefault
   */
  playerId: number;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticFreespinPDefault
   */
  rounds: number;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  totalbet: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  validFrom: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticFreespinPDefault
   */
  validUntil: string;
}
/**
 * PragmaticJackpotwinAction represents a row from public.pragmatic_jackpotwin_action
 * @export
 * @interface DBPragmaticJackpotwinAction
 */
export interface DBPragmaticJackpotwinAction {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  externalGameId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  jackpotId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  pragmaticSession: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  roundId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinAction
   */
  transactionReference: string;
}
/**
 * PragmaticJackpotwinActionP202201 represents a row from public.pragmatic_jackpotwin_action_p_2022_01
 * @export
 * @interface DBPragmaticJackpotwinActionP202201
 */
export interface DBPragmaticJackpotwinActionP202201 {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  externalGameId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  jackpotId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  pragmaticSession: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  roundId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202201
   */
  transactionReference: string;
}
/**
 * PragmaticJackpotwinActionP202301 represents a row from public.pragmatic_jackpotwin_action_p_2023_01
 * @export
 * @interface DBPragmaticJackpotwinActionP202301
 */
export interface DBPragmaticJackpotwinActionP202301 {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  externalGameId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  jackpotId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  pragmaticSession: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  roundId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionP202301
   */
  transactionReference: string;
}
/**
 * PragmaticJackpotwinActionPDefault represents a row from public.pragmatic_jackpotwin_action_p_default
 * @export
 * @interface DBPragmaticJackpotwinActionPDefault
 */
export interface DBPragmaticJackpotwinActionPDefault {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  externalGameId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  jackpotId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  pragmaticSession: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  roundId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticJackpotwinActionPDefault
   */
  transactionReference: string;
}
/**
 * PragmaticPromowinAction represents a row from public.pragmatic_promowin_action
 * @export
 * @interface DBPragmaticPromowinAction
 */
export interface DBPragmaticPromowinAction {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  campaignId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  campaignType: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  pragmaticSession: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinAction
   */
  transactionReference: string;
}
/**
 * PragmaticPromowinActionP202201 represents a row from public.pragmatic_promowin_action_p_2022_01
 * @export
 * @interface DBPragmaticPromowinActionP202201
 */
export interface DBPragmaticPromowinActionP202201 {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  campaignId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  campaignType: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  pragmaticSession: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202201
   */
  transactionReference: string;
}
/**
 * PragmaticPromowinActionP202301 represents a row from public.pragmatic_promowin_action_p_2023_01
 * @export
 * @interface DBPragmaticPromowinActionP202301
 */
export interface DBPragmaticPromowinActionP202301 {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  campaignId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  campaignType: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  pragmaticSession: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionP202301
   */
  transactionReference: string;
}
/**
 * PragmaticPromowinActionPDefault represents a row from public.pragmatic_promowin_action_p_default
 * @export
 * @interface DBPragmaticPromowinActionPDefault
 */
export interface DBPragmaticPromowinActionPDefault {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  campaignId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  campaignType: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  pragmaticSession: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  providerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticPromowinActionPDefault
   */
  transactionReference: string;
}
/**
 * PragmaticToken represents a row from public.pragmatic_token
 * @export
 * @interface DBPragmaticToken
 */
export interface DBPragmaticToken {
  /**
   *
   * @type {string}
   * @memberof DBPragmaticToken
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticToken
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticToken
   */
  externalGameId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticToken
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticToken
   */
  id: string;
  /**
   *
   * @type {boolean}
   * @memberof DBPragmaticToken
   */
  invalidated: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBPragmaticToken
   */
  pragmaticSession: string;
  /**
   *
   * @type {number}
   * @memberof DBPragmaticToken
   */
  webSessionId: number;
}
/**
 * ProductType represents a row from public.product_type
 * @export
 * @interface DBProductType
 */
export interface DBProductType {
  /**
   *
   * @type {string}
   * @memberof DBProductType
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof DBProductType
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBProductType
   */
  name: string;
}
/**
 * RabbitNotification represents a row from public.rabbit_notification
 * @export
 * @interface DBRabbitNotification
 */
export interface DBRabbitNotification {
  /**
   *
   * @type {string}
   * @memberof DBRabbitNotification
   */
  exchange: string;
  /**
   *
   * @type {number}
   * @memberof DBRabbitNotification
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBRabbitNotification
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof DBRabbitNotification
   */
  routingkey: string;
  /**
   *
   * @type {string}
   * @memberof DBRabbitNotification
   */
  toPublishAt: string;
}
/**
 * RecentlyPlayedGame represents a row from public.recently_played_games
 * @export
 * @interface DBRecentlyPlayedGame
 */
export interface DBRecentlyPlayedGame {
  /**
   *
   * @type {string}
   * @memberof DBRecentlyPlayedGame
   */
  gameExternalId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBRecentlyPlayedGame
   */
  gameProvider?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBRecentlyPlayedGame
   */
  playedAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBRecentlyPlayedGame
   */
  playerId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBRecentlyPlayedGame
   */
  slug?: string | null;
}
/**
 * ReportIncomingAccountTransaction represents a row from public.report_incoming_account_transaction
 * @export
 * @interface DBReportIncomingAccountTransaction
 */
export interface DBReportIncomingAccountTransaction {
  /**
   *
   * @type {string}
   * @memberof DBReportIncomingAccountTransaction
   */
  createdAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBReportIncomingAccountTransaction
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBReportIncomingAccountTransaction
   */
  playerHistoryReportBuilt: boolean | null;
}
/**
 * ReportPlayerGameTransaction represents a row from public.report_player_game_transaction
 * @export
 * @interface DBReportPlayerGameTransaction
 */
export interface DBReportPlayerGameTransaction {
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransaction
   */
  accountTransactionCreatedAt: string;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransaction
   */
  accountTransactionId: number;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransaction
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransaction
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransaction
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransaction
   */
  gameId: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransaction
   */
  gameName: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransaction
   */
  operatorId: string;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransaction
   */
  playerId: number;
}
/**
 * ReportPlayerGameTransactionP202001 represents a row from public.report_player_game_transaction_p_2020_01
 * @export
 * @interface DBReportPlayerGameTransactionP202001
 */
export interface DBReportPlayerGameTransactionP202001 {
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  accountTransactionCreatedAt: string;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  accountTransactionId: number;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  gameId: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  gameName: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  operatorId: string;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransactionP202001
   */
  playerId: number;
}
/**
 * ReportPlayerGameTransactionPDefault represents a row from public.report_player_game_transaction_p_default
 * @export
 * @interface DBReportPlayerGameTransactionPDefault
 */
export interface DBReportPlayerGameTransactionPDefault {
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  accountTransactionCreatedAt: string;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  accountTransactionId: number;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  gameId: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  gameName: string;
  /**
   *
   * @type {string}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  operatorId: string;
  /**
   *
   * @type {number}
   * @memberof DBReportPlayerGameTransactionPDefault
   */
  playerId: number;
}
/**
 * Rule represents a row from public.rule
 * @export
 * @interface DBRule
 */
export interface DBRule {
  /**
   *
   * @type {string}
   * @memberof DBRule
   */
  id: string;
}
/**
 * SchemaMigration represents a row from public.schema_migrations
 * @export
 * @interface DBSchemaMigration
 */
export interface DBSchemaMigration {
  /**
   *
   * @type {string}
   * @memberof DBSchemaMigration
   */
  version: string;
}
/**
 * Segment represents a row from public.segment
 * @export
 * @interface DBSegment
 */
export interface DBSegment {
  /**
   *
   * @type {string}
   * @memberof DBSegment
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSegment
   */
  expiresAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBSegment
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSegment
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof DBSegment
   */
  provider: string;
}
/**
 * SegmentPromotionCode represents a row from public.segment_promotion_code
 * @export
 * @interface DBSegmentPromotionCode
 */
export interface DBSegmentPromotionCode {
  /**
   *
   * @type {number}
   * @memberof DBSegmentPromotionCode
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSegmentPromotionCode
   */
  promotionCode: string;
  /**
   *
   * @type {number}
   * @memberof DBSegmentPromotionCode
   */
  segmentId: number;
}
/**
 * SegmentProviderType represents a row from public.segment_provider_type
 * @export
 * @interface DBSegmentProviderType
 */
export interface DBSegmentProviderType {
  /**
   *
   * @type {string}
   * @memberof DBSegmentProviderType
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof DBSegmentProviderType
   */
  id: string;
}
/**
 * SignupFlow represents a row from public.signup_flow
 * @export
 * @interface DBSignupFlow
 */
export interface DBSignupFlow {
  /**
   *
   * @type {string}
   * @memberof DBSignupFlow
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof DBSignupFlow
   */
  id: string;
}
/**
 * Site represents a row from public.site
 * @export
 * @interface DBSite
 */
export interface DBSite {
  /**
   *
   * @type {boolean}
   * @memberof DBSite
   */
  allowCasinoWithoutKyc: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSite
   */
  allowDepositWithoutKyc: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSite
   */
  allowWithdrawWithoutKyc: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSite
   */
  defaultLanguageId: string;
  /**
   *
   * @type {string}
   * @memberof DBSite
   */
  defaultLocaleId: string;
  /**
   *
   * @type {string}
   * @memberof DBSite
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof DBSite
   */
  numberOfFailedLogins: number;
  /**
   *
   * @type {number}
   * @memberof DBSite
   */
  passwordRuleMaxLength: number;
  /**
   *
   * @type {number}
   * @memberof DBSite
   */
  passwordRuleMinLength: number;
  /**
   *
   * @type {number}
   * @memberof DBSite
   */
  passwordRuleMinLowercaseCount: number;
  /**
   *
   * @type {number}
   * @memberof DBSite
   */
  passwordRuleMinNumericCount: number;
  /**
   *
   * @type {number}
   * @memberof DBSite
   */
  passwordRuleMinUppercaseCount: number;
  /**
   *
   * @type {boolean}
   * @memberof DBSite
   */
  playerAgreementAcceptRequired: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSite
   */
  signupFlowId: string;
  /**
   *
   * @type {string}
   * @memberof DBSite
   */
  storyblokSpaceId: string;
  /**
   *
   * @type {string}
   * @memberof DBSite
   */
  urlName: string;
  /**
   *
   * @type {string}
   * @memberof DBSite
   */
  veriffPublicKey: string;
}
/**
 * SiteCountry represents a row from public.site_country
 * @export
 * @interface DBSiteCountry
 */
export interface DBSiteCountry {
  /**
   *
   * @type {string}
   * @memberof DBSiteCountry
   */
  countryId: string;
  /**
   *
   * @type {number}
   * @memberof DBSiteCountry
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteCountry
   */
  siteId: string;
}
/**
 * SiteCurrency represents a row from public.site_currency
 * @export
 * @interface DBSiteCurrency
 */
export interface DBSiteCurrency {
  /**
   *
   * @type {string}
   * @memberof DBSiteCurrency
   */
  currencyId: string;
  /**
   *
   * @type {number}
   * @memberof DBSiteCurrency
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteCurrency
   */
  siteId: string;
}
/**
 * SiteDocumentType represents a row from public.site_document_type
 * @export
 * @interface DBSiteDocumentType
 */
export interface DBSiteDocumentType {
  /**
   *
   * @type {string}
   * @memberof DBSiteDocumentType
   */
  documentTypeId: string;
  /**
   *
   * @type {number}
   * @memberof DBSiteDocumentType
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBSiteDocumentType
   */
  siteId: string;
  /**
   *
   * @type {number}
   * @memberof DBSiteDocumentType
   */
  step: number;
}
/**
 * SiteEligibleBonus represents a row from public.site_eligible_bonuses
 * @export
 * @interface DBSiteEligibleBonus
 */
export interface DBSiteEligibleBonus {
  /**
   *
   * @type {number}
   * @memberof DBSiteEligibleBonus
   */
  bonusId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteEligibleBonus
   */
  currencyId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteEligibleBonus
   */
  siteId?: string | null;
}
/**
 * SiteKycProvider represents a row from public.site_kyc_provider
 * @export
 * @interface DBSiteKycProvider
 */
export interface DBSiteKycProvider {
  /**
   *
   * @type {number}
   * @memberof DBSiteKycProvider
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBSiteKycProvider
   */
  kycProviderId: number;
  /**
   *
   * @type {number}
   * @memberof DBSiteKycProvider
   */
  priority: number;
  /**
   *
   * @type {string}
   * @memberof DBSiteKycProvider
   */
  siteId: string;
}
/**
 * SiteLanguageLocale represents a row from public.site_language_locale
 * @export
 * @interface DBSiteLanguageLocale
 */
export interface DBSiteLanguageLocale {
  /**
   *
   * @type {number}
   * @memberof DBSiteLanguageLocale
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteLanguageLocale
   */
  languageId: string;
  /**
   *
   * @type {string}
   * @memberof DBSiteLanguageLocale
   */
  localeId: string;
  /**
   *
   * @type {string}
   * @memberof DBSiteLanguageLocale
   */
  siteId: string;
}
/**
 * SitePaymentLimit represents a row from public.site_payment_limit
 * @export
 * @interface DBSitePaymentLimit
 */
export interface DBSitePaymentLimit {
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentLimit
   */
  currencyId: string;
  /**
   *
   * @type {number}
   * @memberof DBSitePaymentLimit
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBSitePaymentLimit
   */
  limitTypeId: number;
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentLimit
   */
  maxAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentLimit
   */
  minAmount: string;
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentLimit
   */
  paymentProviderId: string;
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentLimit
   */
  siteId: string;
}
/**
 * SitePaymentProvider represents a row from public.site_payment_provider
 * @export
 * @interface DBSitePaymentProvider
 */
export interface DBSitePaymentProvider {
  /**
   *
   * @type {boolean}
   * @memberof DBSitePaymentProvider
   */
  depositEnabled: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBSitePaymentProvider
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentProvider
   */
  paymentProviderId: string;
  /**
   *
   * @type {boolean}
   * @memberof DBSitePaymentProvider
   */
  priorDepositRequiredToWithdraw: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentProvider
   */
  siteId: string;
  /**
   *
   * @type {boolean}
   * @memberof DBSitePaymentProvider
   */
  withdrawEnabled: boolean | null;
}
/**
 * SitePaymentProviderCategory represents a row from public.site_payment_provider_category
 * @export
 * @interface DBSitePaymentProviderCategory
 */
export interface DBSitePaymentProviderCategory {
  /**
   *
   * @type {number}
   * @memberof DBSitePaymentProviderCategory
   */
  categoryId: number;
  /**
   *
   * @type {number}
   * @memberof DBSitePaymentProviderCategory
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentProviderCategory
   */
  paymentProviderId: string;
  /**
   *
   * @type {string}
   * @memberof DBSitePaymentProviderCategory
   */
  siteId: string;
}
/**
 * SiteRule represents a row from public.site_rule
 * @export
 * @interface DBSiteRule
 */
export interface DBSiteRule {
  /**
   *
   * @type {number}
   * @memberof DBSiteRule
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSiteRule
   */
  isDefault: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSiteRule
   */
  notify: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteRule
   */
  ruleId: string;
  /**
   *
   * @type {string}
   * @memberof DBSiteRule
   */
  siteId: string;
}
/**
 * SiteSession represents a row from public.site_session
 * @export
 * @interface DBSiteSession
 */
export interface DBSiteSession {
  /**
   *
   * @type {string}
   * @memberof DBSiteSession
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSiteSession
   */
  expiresAt: string;
  /**
   *
   * @type {number}
   * @memberof DBSiteSession
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSiteSession
   */
  invalidated: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteSession
   */
  lastUpdatedAt?: string;
  /**
   *
   * @type {number}
   * @memberof DBSiteSession
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBSiteSession
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof DBSiteSession
   */
  token: string;
}
/**
 * SiteSetting represents a row from public.site_settings
 * @export
 * @interface DBSiteSetting
 */
export interface DBSiteSetting {
  /**
   *
   * @type {Array<string>}
   * @memberof DBSiteSetting
   */
  countries: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DBSiteSetting
   */
  currencies: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DBSiteSetting
   */
  defaultLanguage?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteSetting
   */
  id?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSiteSetting
   */
  isPhoneVerificationRequired: boolean | null;
  /**
   *
   * @type {Array<string>}
   * @memberof DBSiteSetting
   */
  languages: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DBSiteSetting
   */
  locale: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DBSiteSetting
   */
  paymentProvidersForDeposits: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DBSiteSetting
   */
  paymentProvidersForWithdrawal: Array<string>;
}
/**
 * SiteTokenSetting represents a row from public.site_token_settings
 * @export
 * @interface DBSiteTokenSetting
 */
export interface DBSiteTokenSetting {
  /**
   *
   * @type {number}
   * @memberof DBSiteTokenSetting
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSiteTokenSetting
   */
  siteId: string;
  /**
   *
   * @type {number}
   * @memberof DBSiteTokenSetting
   */
  tokenTTL: number;
  /**
   *
   * @type {number}
   * @memberof DBSiteTokenSetting
   */
  tokenTypeId: number;
}
/**
 * SlotegratorAction represents a row from public.slotegrator_action
 * @export
 * @interface DBSlotegratorAction
 */
export interface DBSlotegratorAction {
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  betTransactionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  freespinId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  gameUUId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorAction
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  playerId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorAction
   */
  quantity?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  rolledBackByTransactionId?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSlotegratorAction
   */
  roundComplete: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  roundId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  sessionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  transactionId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorAction
   */
  type: string;
}
/**
 * SlotegratorActionP201901 represents a row from public.slotegrator_action_p_2019_01
 * @export
 * @interface DBSlotegratorActionP201901
 */
export interface DBSlotegratorActionP201901 {
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  betTransactionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  freespinId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  gameUUId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorActionP201901
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  playerId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorActionP201901
   */
  quantity?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  rolledBackByTransactionId?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSlotegratorActionP201901
   */
  roundComplete: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  roundId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  sessionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  transactionId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP201901
   */
  type: string;
}
/**
 * SlotegratorActionP202001 represents a row from public.slotegrator_action_p_2020_01
 * @export
 * @interface DBSlotegratorActionP202001
 */
export interface DBSlotegratorActionP202001 {
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  betTransactionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  freespinId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  gameUUId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorActionP202001
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  playerId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorActionP202001
   */
  quantity?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  rolledBackByTransactionId?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSlotegratorActionP202001
   */
  roundComplete: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  roundId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  sessionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  transactionId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionP202001
   */
  type: string;
}
/**
 * SlotegratorActionPDefault represents a row from public.slotegrator_action_p_default
 * @export
 * @interface DBSlotegratorActionPDefault
 */
export interface DBSlotegratorActionPDefault {
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  betTransactionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  currency?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  freespinId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  gameUUId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorActionPDefault
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  playerId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorActionPDefault
   */
  quantity?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  rolledBackByTransactionId?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSlotegratorActionPDefault
   */
  roundComplete: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  roundId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  sessionId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  transactionId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorActionPDefault
   */
  type: string;
}
/**
 * SlotegratorFreespin represents a row from public.slotegrator_freespin
 * @export
 * @interface DBSlotegratorFreespin
 */
export interface DBSlotegratorFreespin {
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  betId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  denomination?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  freespinId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  gameUUId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorFreespin
   */
  id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof DBSlotegratorFreespin
   */
  isCanceled: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorFreespin
   */
  playerId: number;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorFreespin
   */
  quantity: number;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorFreespin
   */
  quantityLeft: number;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  totalBetId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  totalWin: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  validFrom: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespin
   */
  validUntil: string;
}
/**
 * SlotegratorFreespinPDefault represents a row from public.slotegrator_freespin_p_default
 * @export
 * @interface DBSlotegratorFreespinPDefault
 */
export interface DBSlotegratorFreespinPDefault {
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  betId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  denomination?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  freespinId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  gameUUId: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorFreespinPDefault
   */
  id: number;
  /**
   *
   * @type {boolean}
   * @memberof DBSlotegratorFreespinPDefault
   */
  isCanceled: boolean | null;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorFreespinPDefault
   */
  playerId: number;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorFreespinPDefault
   */
  quantity: number;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorFreespinPDefault
   */
  quantityLeft: number;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  totalBetId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  totalWin: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  validFrom: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorFreespinPDefault
   */
  validUntil: string;
}
/**
 * SlotegratorToken represents a row from public.slotegrator_token
 * @export
 * @interface DBSlotegratorToken
 */
export interface DBSlotegratorToken {
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorToken
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorToken
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof DBSlotegratorToken
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof DBSlotegratorToken
   */
  webSessionId: number;
}
/**
 * SoftswissAction represents a row from public.softswiss_action
 * @export
 * @interface DBSoftswissAction
 */
export interface DBSoftswissAction {
  /**
   *
   * @type {string}
   * @memberof DBSoftswissAction
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissAction
   */
  actionId: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissAction
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissAction
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissAction
   */
  currency: string;
  /**
   *
   * @type {boolean}
   * @memberof DBSoftswissAction
   */
  finished: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissAction
   */
  game: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissAction
   */
  gameId: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissAction
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissAction
   */
  jackpotContribution: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissAction
   */
  jackpotWin?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissAction
   */
  userId: string;
}
/**
 * SoftswissActionP202201 represents a row from public.softswiss_action_p_2022_01
 * @export
 * @interface DBSoftswissActionP202201
 */
export interface DBSoftswissActionP202201 {
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202201
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202201
   */
  actionId: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionP202201
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202201
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202201
   */
  currency: string;
  /**
   *
   * @type {boolean}
   * @memberof DBSoftswissActionP202201
   */
  finished: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202201
   */
  game: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202201
   */
  gameId: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionP202201
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202201
   */
  jackpotContribution: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionP202201
   */
  jackpotWin?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202201
   */
  userId: string;
}
/**
 * SoftswissActionP202301 represents a row from public.softswiss_action_p_2023_01
 * @export
 * @interface DBSoftswissActionP202301
 */
export interface DBSoftswissActionP202301 {
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202301
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202301
   */
  actionId: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionP202301
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202301
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202301
   */
  currency: string;
  /**
   *
   * @type {boolean}
   * @memberof DBSoftswissActionP202301
   */
  finished: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202301
   */
  game: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202301
   */
  gameId: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionP202301
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202301
   */
  jackpotContribution: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionP202301
   */
  jackpotWin?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionP202301
   */
  userId: string;
}
/**
 * SoftswissActionPDefault represents a row from public.softswiss_action_p_default
 * @export
 * @interface DBSoftswissActionPDefault
 */
export interface DBSoftswissActionPDefault {
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionPDefault
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionPDefault
   */
  actionId: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionPDefault
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionPDefault
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionPDefault
   */
  currency: string;
  /**
   *
   * @type {boolean}
   * @memberof DBSoftswissActionPDefault
   */
  finished: boolean | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionPDefault
   */
  game: string;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionPDefault
   */
  gameId: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionPDefault
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionPDefault
   */
  jackpotContribution: string;
  /**
   *
   * @type {number}
   * @memberof DBSoftswissActionPDefault
   */
  jackpotWin?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBSoftswissActionPDefault
   */
  userId: string;
}
/**
 * Subscription represents a row from public.subscription
 * @export
 * @interface DBSubscription
 */
export interface DBSubscription {
  /**
   *
   * @type {string}
   * @memberof DBSubscription
   */
  email: string;
}
/**
 * Token represents a row from public.token
 * @export
 * @interface DBToken
 */
export interface DBToken {
  /**
   *
   * @type {string}
   * @memberof DBToken
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBToken
   */
  expiresAt: string;
  /**
   *
   * @type {number}
   * @memberof DBToken
   */
  id?: number | null;
  /**
   *
   * @type {object}
   * @memberof DBToken
   */
  payload: object;
  /**
   *
   * @type {string}
   * @memberof DBToken
   */
  token: string;
  /**
   *
   * @type {number}
   * @memberof DBToken
   */
  typeId: number;
}
/**
 * TokenType represents a row from public.token_type
 * @export
 * @interface DBTokenType
 */
export interface DBTokenType {
  /**
   *
   * @type {string}
   * @memberof DBTokenType
   */
  displayName?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBTokenType
   */
  id?: number | null;
}
/**
 * VPlayerBetTotal represents a row from public.v_player_bet_total
 * @export
 * @interface DBVPlayerBetTotal
 */
export interface DBVPlayerBetTotal {
  /**
   *
   * @type {string}
   * @memberof DBVPlayerBetTotal
   */
  currencyId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBVPlayerBetTotal
   */
  playerId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBVPlayerBetTotal
   */
  total: string;
}
/**
 * VeriffKycDecision represents a row from public.veriff_kyc_decision
 * @export
 * @interface DBVeriffKycDecision
 */
export interface DBVeriffKycDecision {
  /**
   *
   * @type {string}
   * @memberof DBVeriffKycDecision
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBVeriffKycDecision
   */
  externalVerificationSessionId: string;
  /**
   *
   * @type {number}
   * @memberof DBVeriffKycDecision
   */
  id?: number | null;
  /**
   *
   * @type {number}
   * @memberof DBVeriffKycDecision
   */
  playerId: number;
  /**
   *
   * @type {boolean}
   * @memberof DBVeriffKycDecision
   */
  processed: boolean | null;
  /**
   *
   * @type {object}
   * @memberof DBVeriffKycDecision
   */
  rawData: object;
}
/**
 * Withdraw represents a row from public.withdraw
 * @export
 * @interface DBWithdraw
 */
export interface DBWithdraw {
  /**
   *
   * @type {number}
   * @memberof DBWithdraw
   */
  accountId: number;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  address?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  approvedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  approvedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  cancelledAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  confirmedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  executedAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBWithdraw
   */
  externalTransactionId?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  faultedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  frozenAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  frozenByUserId?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBWithdraw
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  paymentProviderId: string;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  paymentServiceError?: string | null;
  /**
   *
   * @type {number}
   * @memberof DBWithdraw
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  reason?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  rejectedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  rejectedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  retriedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  retriedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof DBWithdraw
   */
  status: string;
}
/**
 * WithdrawStatus represents a row from public.withdraw_status
 * @export
 * @interface DBWithdrawStatus
 */
export interface DBWithdrawStatus {
  /**
   *
   * @type {string}
   * @memberof DBWithdrawStatus
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof DBWithdrawStatus
   */
  id: string;
}
/**
 * WorkerSharedLock represents a row from public.worker_shared_lock
 * @export
 * @interface DBWorkerSharedLock
 */
export interface DBWorkerSharedLock {
  /**
   *
   * @type {string}
   * @memberof DBWorkerSharedLock
   */
  lastCompletedAt: string;
  /**
   *
   * @type {string}
   * @memberof DBWorkerSharedLock
   */
  name: string;
}
/**
 * WsNotification represents a row from public.ws_notification
 * @export
 * @interface DBWsNotification
 */
export interface DBWsNotification {
  /**
   *
   * @type {number}
   * @memberof DBWsNotification
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DBWsNotification
   */
  payload: string;
  /**
   *
   * @type {string}
   * @memberof DBWsNotification
   */
  payloadType: string;
  /**
   *
   * @type {number}
   * @memberof DBWsNotification
   */
  playerId: number;
}
/**
 *
 * @export
 * @interface DefaultSuccessResponse
 */
export interface DefaultSuccessResponse {
  /**
   *
   * @type {string}
   * @memberof DefaultSuccessResponse
   */
  status?: string;
}
/**
 * Deposit transaction
 * @export
 * @interface Deposit
 */
export interface Deposit {
  /**
   *
   * @type {string}
   * @memberof Deposit
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof Deposit
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof Deposit
   */
  currencyId: string;
  /**
   *
   * @type {number}
   * @memberof Deposit
   */
  externalTransactionId: number;
  /**
   *
   * @type {string}
   * @memberof Deposit
   */
  fundedAt?: string;
  /**
   *
   * @type {number}
   * @memberof Deposit
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof Deposit
   */
  number: number;
  /**
   *
   * @type {number}
   * @memberof Deposit
   */
  paymentAccountId?: number;
  /**
   *
   * @type {string}
   * @memberof Deposit
   */
  paymentProviderId: string;
  /**
   *
   * @type {number}
   * @memberof Deposit
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof Deposit
   */
  reason?: string | null;
  /**
   *
   * @type {string}
   * @memberof Deposit
   */
  status: string;
}
/**
 *
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
  /**
   * attributes
   * @type {{ [key: string]: string; }}
   * @memberof ErrorMessage
   */
  attributes?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof ErrorMessage
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorMessage
   */
  message: string;
}
/**
 *
 * @export
 * @interface ExecuteWithdrawRequest
 */
export interface ExecuteWithdrawRequest {
  /**
   *
   * @type {number}
   * @memberof ExecuteWithdrawRequest
   */
  txid: number;
  /**
   *
   * @type {number}
   * @memberof ExecuteWithdrawRequest
   */
  withdrawId: number;
}
/**
 *
 * @export
 * @interface FailWithdrawRequest
 */
export interface FailWithdrawRequest {
  /**
   *
   * @type {string}
   * @memberof FailWithdrawRequest
   */
  failReason: string;
  /**
   *
   * @type {number}
   * @memberof FailWithdrawRequest
   */
  withdrawId: number;
}
/**
 *
 * @export
 * @interface FreespinActivateRequest
 */
export interface FreespinActivateRequest {
  /**
   *
   * @type {string}
   * @memberof FreespinActivateRequest
   */
  betsAbetId?: string | null;
  /**
   *
   * @type {string}
   * @memberof FreespinActivateRequest
   */
  betsBbetId?: string | null;
  /**
   *
   * @type {string}
   * @memberof FreespinActivateRequest
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof FreespinActivateRequest
   */
  denomination?: string | null;
  /**
   *
   * @type {number}
   * @memberof FreespinActivateRequest
   */
  gameId?: number;
  /**
   *
   * @type {number}
   * @memberof FreespinActivateRequest
   */
  playerId?: number;
  /**
   *
   * @type {number}
   * @memberof FreespinActivateRequest
   */
  quantity?: number;
  /**
   * Value of total bet in the specified currency, which will be applied during free rounds
   * @type {string}
   * @memberof FreespinActivateRequest
   */
  totalBetAmount?: string | null;
  /**
   *
   * @type {string}
   * @memberof FreespinActivateRequest
   */
  validFrom?: string;
  /**
   *
   * @type {string}
   * @memberof FreespinActivateRequest
   */
  validUntil?: string;
}
/**
 *
 * @export
 * @interface FreespinActivatedResponse
 */
export interface FreespinActivatedResponse {
  /**
   *
   * @type {string}
   * @memberof FreespinActivatedResponse
   */
  freespinId?: string;
}
/**
 *
 * @export
 * @interface FreespinBetsRequest
 */
export interface FreespinBetsRequest {
  /**
   *
   * @type {string}
   * @memberof FreespinBetsRequest
   */
  currency?: string;
  /**
   *
   * @type {number}
   * @memberof FreespinBetsRequest
   */
  gameId?: number;
}
/**
 *
 * @export
 * @interface FreespinBetsResponse
 */
export interface FreespinBetsResponse {
  /**
   *
   * @type {Array<FreespinExtraBetLine>}
   * @memberof FreespinBetsResponse
   */
  betLines?: Array<FreespinExtraBetLine>;
  /**
   *
   * @type {Array<FreespinExtraBetTotal>}
   * @memberof FreespinBetsResponse
   */
  betTotals?: Array<FreespinExtraBetTotal>;
  /**
   *
   * @type {Array<string>}
   * @memberof FreespinBetsResponse
   */
  denominations?: Array<string>;
}
/**
 *
 * @export
 * @interface FreespinCancelRequest
 */
export interface FreespinCancelRequest {
  /**
   *
   * @type {string}
   * @memberof FreespinCancelRequest
   */
  freespinId?: string;
}
/**
 *
 * @export
 * @interface FreespinExtraBetLine
 */
export interface FreespinExtraBetLine {
  /**
   *
   * @type {string}
   * @memberof FreespinExtraBetLine
   */
  betId?: string;
  /**
   *
   * @type {string}
   * @memberof FreespinExtraBetLine
   */
  betPerLine?: string;
  /**
   *
   * @type {number}
   * @memberof FreespinExtraBetLine
   */
  lines?: number;
}
/**
 *
 * @export
 * @interface FreespinExtraBetTotal
 */
export interface FreespinExtraBetTotal {
  /**
   *
   * @type {string}
   * @memberof FreespinExtraBetTotal
   */
  amount?: string;
  /**
   *
   * @type {string}
   * @memberof FreespinExtraBetTotal
   */
  betId?: string;
}
/**
 *
 * @export
 * @interface FreespinGetResponse
 */
export interface FreespinGetResponse {
  /**
   *
   * @type {string}
   * @memberof FreespinGetResponse
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof FreespinGetResponse
   */
  playerExternalId?: string;
  /**
   *
   * @type {number}
   * @memberof FreespinGetResponse
   */
  quantity?: number;
  /**
   *
   * @type {number}
   * @memberof FreespinGetResponse
   */
  quantityLeft?: number;
}
/**
 *
 * @export
 * @interface FreezeWithdrawRequest
 */
export interface FreezeWithdrawRequest {
  /**
   *
   * @type {string}
   * @memberof FreezeWithdrawRequest
   */
  freezedByUserId: string;
  /**
   *
   * @type {number}
   * @memberof FreezeWithdrawRequest
   */
  withdrawId: number;
}
/**
 * Game favourites request
 * @export
 * @interface GameFavouritesRequest
 */
export interface GameFavouritesRequest {
  /**
   *
   * @type {number}
   * @memberof GameFavouritesRequest
   */
  gameId: number;
}
/**
 * Game favourites request
 * @export
 * @interface GameFavouritesResponse
 */
export interface GameFavouritesResponse {
  /**
   *
   * @type {string}
   * @memberof GameFavouritesResponse
   */
  createdAt: string;
  /**
   *
   * @type {number}
   * @memberof GameFavouritesResponse
   */
  gameId: number;
  /**
   *
   * @type {number}
   * @memberof GameFavouritesResponse
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof GameFavouritesResponse
   */
  playerId: number;
}
/**
 *
 * @export
 * @interface KycResolution
 */
export interface KycResolution {
  /**
   *
   * @type {number}
   * @memberof KycResolution
   */
  application_id: number;
  /**
   *
   * @type {boolean}
   * @memberof KycResolution
   */
  approved?: boolean;
  /**
   *
   * @type {string}
   * @memberof KycResolution
   */
  expires_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof KycResolution
   */
  reason?: string | null;
}
/**
 *
 * @export
 * @interface LivenessProbe
 */
export interface LivenessProbe {
  /**
   *
   * @type {Array<LivenessProbeComponent>}
   * @memberof LivenessProbe
   */
  components?: Array<LivenessProbeComponent>;
  /**
   *
   * @type {string}
   * @memberof LivenessProbe
   */
  tag: string;
}
/**
 *
 * @export
 * @interface LivenessProbeComponent
 */
export interface LivenessProbeComponent {
  /**
   *
   * @type {string}
   * @memberof LivenessProbeComponent
   */
  name: string;
  /**
   *
   * @type {boolean}
   * @memberof LivenessProbeComponent
   */
  status: boolean;
}
/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  loginIP: string;
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  userAgent: string;
}
/**
 *
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
  /**
   *
   * @type {boolean}
   * @memberof LoginResponse
   */
  agreementTermsAccepted: boolean;
  /**
   *
   * @type {boolean}
   * @memberof LoginResponse
   */
  consentPhone: boolean;
  /**
   *
   * @type {boolean}
   * @memberof LoginResponse
   */
  consentPostmail: boolean;
  /**
   *
   * @type {boolean}
   * @memberof LoginResponse
   */
  consentPush: boolean;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  countryId: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  dateOfBirth: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  displayName?: string | null;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  genderId: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  languageId: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  lastName: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LoginResponse
   */
  permissions: Array<string>;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  phoneCode: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  phoneNumber: string;
  /**
   *
   * @type {number}
   * @memberof LoginResponse
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  postalCode: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  siteSessionToken: string;
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  street: string;
  /**
   *
   * @type {boolean}
   * @memberof LoginResponse
   */
  subscriptionEmailEnabled: boolean;
  /**
   *
   * @type {boolean}
   * @memberof LoginResponse
   */
  subscriptionSmsEnabled: boolean;
}
/**
 *
 * @export
 * @interface MakeDepositRequest
 */
export interface MakeDepositRequest {
  /**
   *
   * @type {string}
   * @memberof MakeDepositRequest
   */
  amount: string;
  /**
   *
   * @type {number}
   * @memberof MakeDepositRequest
   */
  bonusId?: number | null;
  /**
   *
   * @type {string}
   * @memberof MakeDepositRequest
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof MakeDepositRequest
   */
  provider: string;
  /**
   *
   * @type {number}
   * @memberof MakeDepositRequest
   */
  txid: number;
}
/**
 *
 * @export
 * @interface PlayerBonus
 */
export interface PlayerBonus {
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  bonus: string;
  /**
   *
   * @type {number}
   * @memberof PlayerBonus
   */
  bonusId: number;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  bonusName: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  bonusStatus?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  cancelledAmount: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  convertedAmount: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  endsAt: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  expiredAmount: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  forfeitedAmount: string;
  /**
   *
   * @type {number}
   * @memberof PlayerBonus
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  initialBonus: string;
  /**
   *
   * @type {number}
   * @memberof PlayerBonus
   */
  playerBonusId: number;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  restrictedAmount: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  storyBlokId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  wagerRequiredAmount: string;
  /**
   *
   * @type {string}
   * @memberof PlayerBonus
   */
  wagerTotalAmount: string;
}
/**
 *
 * @export
 * @interface PlayerChangePasswordRequest
 */
export interface PlayerChangePasswordRequest {
  /**
   *
   * @type {string}
   * @memberof PlayerChangePasswordRequest
   */
  newPassword: string;
}
/**
 *
 * @export
 * @interface PlayerEligibleBonus
 */
export interface PlayerEligibleBonus {
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  autoforfeitMaxAmount?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  awardMaxAmount?: string | null;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  betMaxAmount?: string;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  bonusId?: number;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  bonusName?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  currencyId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  depositMinAmount?: string;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  depositNumber?: number | null;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  endsAt?: string;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  expiresInDays?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  maxReceivedCount?: number | null;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  maxReceivedResetInDays?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  productTypeId?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  rewardPercent?: number;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  rewardType?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  startsAt?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  storyBlockId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  triggerDescription?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerEligibleBonus
   */
  triggerName?: string;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  triggerTypeId?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  utcOffset?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerEligibleBonus
   */
  wagerMultiplier?: number | null;
}
/**
 *
 * @export
 * @interface PlayerGameHistoryRecord
 */
export interface PlayerGameHistoryRecord {
  /**
   *
   * @type {string}
   * @memberof PlayerGameHistoryRecord
   */
  amount?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerGameHistoryRecord
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerGameHistoryRecord
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerGameHistoryRecord
   */
  gameName?: string;
  /**
   *
   * @type {number}
   * @memberof PlayerGameHistoryRecord
   */
  txid?: number;
}
/**
 *
 * @export
 * @interface PlayerInfoResponse
 */
export interface PlayerInfoResponse {
  /**
   *
   * @type {boolean}
   * @memberof PlayerInfoResponse
   */
  agreementTermsAccepted: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PlayerInfoResponse
   */
  consentPhone: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PlayerInfoResponse
   */
  consentPostmail: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PlayerInfoResponse
   */
  consentPush: boolean;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  countryId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  dateOfBirth: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  displayName?: string | null;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  externalPlayerId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  genderId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  languageId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  lastName: string;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerInfoResponse
   */
  permissions: Array<string>;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  phoneCode: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  phoneNumber: string;
  /**
   *
   * @type {number}
   * @memberof PlayerInfoResponse
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  postalCode: string;
  /**
   *
   * @type {string}
   * @memberof PlayerInfoResponse
   */
  street: string;
  /**
   *
   * @type {boolean}
   * @memberof PlayerInfoResponse
   */
  subscriptionEmailEnabled: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PlayerInfoResponse
   */
  subscriptionSmsEnabled: boolean;
}
/**
 *
 * @export
 * @interface PlayerKycApplication
 */
export interface PlayerKycApplication {
  /**
   *
   * @type {string}
   * @memberof PlayerKycApplication
   */
  document_type: string;
  /**
   * s3 urls
   * @type {Array<string>}
   * @memberof PlayerKycApplication
   */
  urls: Array<string>;
}
/**
 *
 * @export
 * @interface PlayerKycDocument
 */
export interface PlayerKycDocument {
  /**
   *
   * @type {string}
   * @memberof PlayerKycDocument
   */
  document_type: string;
  /**
   *
   * @type {string}
   * @memberof PlayerKycDocument
   */
  url: string;
}
/**
 *
 * @export
 * @interface PragmaticPlayAuthenticateResponse
 */
export interface PragmaticPlayAuthenticateResponse {
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayAuthenticateResponse
   */
  bonus?: number;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayAuthenticateResponse
   */
  cash?: number;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayAuthenticateResponse
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayAuthenticateResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayAuthenticateResponse
   */
  error: number;
  /**
   * Token/session of the player.
   * @type {string}
   * @memberof PragmaticPlayAuthenticateResponse
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayAuthenticateResponse
   */
  userId?: string;
}
/**
 *
 * @export
 * @interface PragmaticPlayBalanceResponse
 */
export interface PragmaticPlayBalanceResponse {
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayBalanceResponse
   */
  bonus: number;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayBalanceResponse
   */
  cash: number;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayBalanceResponse
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayBalanceResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayBalanceResponse
   */
  error: number;
}
/**
 *
 * @export
 * @interface PragmaticPlayBetResponse
 */
export interface PragmaticPlayBetResponse {
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayBetResponse
   */
  bonus?: number | null;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayBetResponse
   */
  cash?: number | null;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayBetResponse
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayBetResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayBetResponse
   */
  error: number;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayBetResponse
   */
  transactionId?: number;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayBetResponse
   */
  usedPromo?: number | null;
}
/**
 *
 * @export
 * @interface PragmaticPlayRefundResponse
 */
export interface PragmaticPlayRefundResponse {
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayRefundResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayRefundResponse
   */
  error: number;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayRefundResponse
   */
  transactionId?: string | null;
}
/**
 *
 * @export
 * @interface PragmaticPlayResultResponse
 */
export interface PragmaticPlayResultResponse {
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayResultResponse
   */
  bonus?: number | null;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayResultResponse
   */
  cash?: number | null;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayResultResponse
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayResultResponse
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof PragmaticPlayResultResponse
   */
  error: number;
  /**
   *
   * @type {string}
   * @memberof PragmaticPlayResultResponse
   */
  transactionId?: string;
}
/**
 *
 * @export
 * @interface PragmaticplayDemoGameRequest
 */
export interface PragmaticplayDemoGameRequest {
  /**
   *
   * @type {string}
   * @memberof PragmaticplayDemoGameRequest
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticplayDemoGameRequest
   */
  gameId?: string;
}
/**
 *
 * @export
 * @interface PragmaticplayDemoGameResponse
 */
export interface PragmaticplayDemoGameResponse {
  /**
   *
   * @type {string}
   * @memberof PragmaticplayDemoGameResponse
   */
  url?: string;
}
/**
 *
 * @export
 * @interface PragmaticplayStartGameRequest
 */
export interface PragmaticplayStartGameRequest {
  /**
   *
   * @type {string}
   * @memberof PragmaticplayStartGameRequest
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticplayStartGameRequest
   */
  gameId: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticplayStartGameRequest
   */
  ip: string;
  /**
   *
   * @type {boolean}
   * @memberof PragmaticplayStartGameRequest
   */
  isMobile?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof PragmaticplayStartGameRequest
   */
  jurisdiction?: string | null;
  /**
   *
   * @type {string}
   * @memberof PragmaticplayStartGameRequest
   */
  locale: string;
  /**
   *
   * @type {number}
   * @memberof PragmaticplayStartGameRequest
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof PragmaticplayStartGameRequest
   */
  returnURL: string;
  /**
   *
   * @type {string}
   * @memberof PragmaticplayStartGameRequest
   */
  siteSessionToken: string;
}
/**
 *
 * @export
 * @interface PragmaticplayStartGameResponse
 */
export interface PragmaticplayStartGameResponse {
  /**
   *
   * @type {string}
   * @memberof PragmaticplayStartGameResponse
   */
  url?: string;
}
/**
 *
 * @export
 * @interface RejectWithdrawRequest
 */
export interface RejectWithdrawRequest {
  /**
   * userId
   * @type {string}
   * @memberof RejectWithdrawRequest
   */
  rejectedByUserId: string;
  /**
   *
   * @type {string}
   * @memberof RejectWithdrawRequest
   */
  rejectionReason: string;
  /**
   *
   * @type {number}
   * @memberof RejectWithdrawRequest
   */
  withdrawId: number;
}
/**
 *
 * @export
 * @interface RequestWithdrawRequest
 */
export interface RequestWithdrawRequest {
  /**
   *
   * @type {string}
   * @memberof RequestWithdrawRequest
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof RequestWithdrawRequest
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof RequestWithdrawRequest
   */
  paymentProviderId: string;
}
/**
 *
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
  /**
   *
   * @type {string}
   * @memberof ResetPasswordRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ResetPasswordRequest
   */
  siteId: string;
}
/**
 *
 * @export
 * @interface ResetPasswordResponse
 */
export interface ResetPasswordResponse {
  /**
   *
   * @type {string}
   * @memberof ResetPasswordResponse
   */
  token: string;
}
/**
 *
 * @export
 * @interface RetryWithdrawRequest
 */
export interface RetryWithdrawRequest {
  /**
   *
   * @type {string}
   * @memberof RetryWithdrawRequest
   */
  retriedByUserId: string;
  /**
   *
   * @type {number}
   * @memberof RetryWithdrawRequest
   */
  withdrawId: number;
}
/**
 * Start Incentives Request
 * @export
 * @interface SearchPlayerEligibleBonusesRequest
 */
export interface SearchPlayerEligibleBonusesRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof SearchPlayerEligibleBonusesRequest
   */
  bonusTriggerTypeId?: Array<number>;
}
/**
 * Search player game history request
 * @export
 * @interface SearchPlayerGameHistoryRequest
 */
export interface SearchPlayerGameHistoryRequest {
  /**
   *
   * @type {number}
   * @memberof SearchPlayerGameHistoryRequest
   */
  days?: number;
}
/**
 *
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  countryId?: string | null;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  currencyId: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  dateOfBirth: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  displayName: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  firstName?: string | null;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  genderId: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  ipAddress: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  languageId: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  lastName?: string | null;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  referrer: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  userAgent: string;
}
/**
 *
 * @export
 * @interface SignupResponse
 */
export interface SignupResponse {
  /**
   *
   * @type {string}
   * @memberof SignupResponse
   */
  token: string;
}
/**
 *
 * @export
 * @interface SlotegratorActionRequest
 */
export interface SlotegratorActionRequest {
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  bet_transaction_id?: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  freespin_id?: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  game_uuid: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  player_id: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  quantity?: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  session_id?: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  transaction_id: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionRequest
   */
  type: string;
}
/**
 *
 * @export
 * @interface SlotegratorActionResponse
 */
export interface SlotegratorActionResponse {
  /**
   *
   * @type {object}
   * @memberof SlotegratorActionResponse
   */
  balance: object;
  /**
   *
   * @type {Array<string>}
   * @memberof SlotegratorActionResponse
   */
  rollback_transactions?: Array<string> | null;
  /**
   *
   * @type {string}
   * @memberof SlotegratorActionResponse
   */
  transaction_id?: string | null;
}
/**
 *
 * @export
 * @interface SlotegratorDemoGameRequest
 */
export interface SlotegratorDemoGameRequest {
  /**
   *
   * @type {string}
   * @memberof SlotegratorDemoGameRequest
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorDemoGameRequest
   */
  gameId?: string;
}
/**
 *
 * @export
 * @interface SlotegratorDemoGameResponse
 */
export interface SlotegratorDemoGameResponse {
  /**
   *
   * @type {string}
   * @memberof SlotegratorDemoGameResponse
   */
  url?: string;
}
/**
 *
 * @export
 * @interface SlotegratorErrorResponse
 */
export interface SlotegratorErrorResponse {
  /**
   *
   * @type {string}
   * @memberof SlotegratorErrorResponse
   */
  error_code: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorErrorResponse
   */
  error_description: string;
}
/**
 *
 * @export
 * @interface SlotegratorStartGameRequest
 */
export interface SlotegratorStartGameRequest {
  /**
   *
   * @type {string}
   * @memberof SlotegratorStartGameRequest
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof SlotegratorStartGameRequest
   */
  gameId?: string;
  /**
   *
   * @type {number}
   * @memberof SlotegratorStartGameRequest
   */
  playerId?: number;
  /**
   *
   * @type {string}
   * @memberof SlotegratorStartGameRequest
   */
  siteSessionToken?: string;
}
/**
 *
 * @export
 * @interface SlotegratorStartGameResponse
 */
export interface SlotegratorStartGameResponse {
  /**
   *
   * @type {string}
   * @memberof SlotegratorStartGameResponse
   */
  url?: string;
}
/**
 *
 * @export
 * @interface SoftSwissDemoGameRequest
 */
export interface SoftSwissDemoGameRequest {
  /**
   *
   * @type {string}
   * @memberof SoftSwissDemoGameRequest
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissDemoGameRequest
   */
  gameId?: string;
}
/**
 *
 * @export
 * @interface SoftSwissDemoGameResponse
 */
export interface SoftSwissDemoGameResponse {
  /**
   *
   * @type {string}
   * @memberof SoftSwissDemoGameResponse
   */
  url?: string;
}
/**
 *
 * @export
 * @interface SoftSwissErrorResponse
 */
export interface SoftSwissErrorResponse {
  /**
   *
   * @type {number}
   * @memberof SoftSwissErrorResponse
   */
  balance?: number | null;
  /**
   *
   * @type {number}
   * @memberof SoftSwissErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof SoftSwissErrorResponse
   */
  message?: string;
}
/**
 *
 * @export
 * @interface SoftSwissPlayRequest
 */
export interface SoftSwissPlayRequest {
  /**
   *
   * @type {Array<SoftSwissPlayRequestAction>}
   * @memberof SoftSwissPlayRequest
   */
  actions?: Array<SoftSwissPlayRequestAction>;
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayRequest
   */
  currency: string;
  /**
   *
   * @type {boolean}
   * @memberof SoftSwissPlayRequest
   */
  finished?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayRequest
   */
  game: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayRequest
   */
  game_id?: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayRequest
   */
  user_id: string;
}
/**
 *
 * @export
 * @interface SoftSwissPlayRequestAction
 */
export interface SoftSwissPlayRequestAction {
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayRequestAction
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayRequestAction
   */
  action_id: string;
  /**
   *
   * @type {number}
   * @memberof SoftSwissPlayRequestAction
   */
  amount: number | null;
  /**
   *
   * @type {number}
   * @memberof SoftSwissPlayRequestAction
   */
  jackpot_contribution?: number | null;
  /**
   *
   * @type {number}
   * @memberof SoftSwissPlayRequestAction
   */
  jackpot_win?: number | null;
}
/**
 *
 * @export
 * @interface SoftSwissPlayResponse
 */
export interface SoftSwissPlayResponse {
  /**
   *
   * @type {number}
   * @memberof SoftSwissPlayResponse
   */
  balance: number | null;
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayResponse
   */
  game_id?: string;
  /**
   *
   * @type {Array<SoftSwissPlayResponseTransaction>}
   * @memberof SoftSwissPlayResponse
   */
  transactions?: Array<SoftSwissPlayResponseTransaction>;
}
/**
 *
 * @export
 * @interface SoftSwissPlayResponseTransaction
 */
export interface SoftSwissPlayResponseTransaction {
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayResponseTransaction
   */
  action_id: string;
  /**
   *
   * @type {number}
   * @memberof SoftSwissPlayResponseTransaction
   */
  bonus_amount?: number | null;
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayResponseTransaction
   */
  processed_at: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissPlayResponseTransaction
   */
  tx_id: string;
}
/**
 *
 * @export
 * @interface SoftSwissRollbackRequest
 */
export interface SoftSwissRollbackRequest {
  /**
   *
   * @type {Array<SoftSwissRollbackRequestAction>}
   * @memberof SoftSwissRollbackRequest
   */
  actions: Array<SoftSwissRollbackRequestAction>;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackRequest
   */
  currency: string;
  /**
   *
   * @type {boolean}
   * @memberof SoftSwissRollbackRequest
   */
  finished?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackRequest
   */
  game: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackRequest
   */
  game_id: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackRequest
   */
  user_id: string;
}
/**
 *
 * @export
 * @interface SoftSwissRollbackRequestAction
 */
export interface SoftSwissRollbackRequestAction {
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackRequestAction
   */
  action: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackRequestAction
   */
  action_id: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackRequestAction
   */
  original_action_id: string;
}
/**
 *
 * @export
 * @interface SoftSwissRollbackResponse
 */
export interface SoftSwissRollbackResponse {
  /**
   *
   * @type {number}
   * @memberof SoftSwissRollbackResponse
   */
  balance: number | null;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackResponse
   */
  game_id: string;
  /**
   *
   * @type {Array<SoftSwissRollbackResponseTransaction>}
   * @memberof SoftSwissRollbackResponse
   */
  transactions: Array<SoftSwissRollbackResponseTransaction>;
}
/**
 *
 * @export
 * @interface SoftSwissRollbackResponseTransaction
 */
export interface SoftSwissRollbackResponseTransaction {
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackResponseTransaction
   */
  action_id: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackResponseTransaction
   */
  processed_at: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissRollbackResponseTransaction
   */
  tx_id: string | null;
}
/**
 *
 * @export
 * @interface SoftSwissStartGameRequest
 */
export interface SoftSwissStartGameRequest {
  /**
   *
   * @type {string}
   * @memberof SoftSwissStartGameRequest
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissStartGameRequest
   */
  gameId: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissStartGameRequest
   */
  ip: string;
  /**
   *
   * @type {boolean}
   * @memberof SoftSwissStartGameRequest
   */
  isMobile?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof SoftSwissStartGameRequest
   */
  jurisdiction?: string | null;
  /**
   *
   * @type {string}
   * @memberof SoftSwissStartGameRequest
   */
  locale: string;
  /**
   *
   * @type {number}
   * @memberof SoftSwissStartGameRequest
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof SoftSwissStartGameRequest
   */
  returnURL: string;
  /**
   *
   * @type {string}
   * @memberof SoftSwissStartGameRequest
   */
  siteSessionToken: string;
}
/**
 *
 * @export
 * @interface SoftSwissStartGameResponse
 */
export interface SoftSwissStartGameResponse {
  /**
   *
   * @type {string}
   * @memberof SoftSwissStartGameResponse
   */
  url?: string;
}
/**
 * Start Incentives Request
 * @export
 * @interface StartPlayerBonusRequest
 */
export interface StartPlayerBonusRequest {
  /**
   *
   * @type {number}
   * @memberof StartPlayerBonusRequest
   */
  bonusId?: number;
  /**
   *
   * @type {string}
   * @memberof StartPlayerBonusRequest
   */
  initialReward?: string;
}
/**
 *
 * @export
 * @interface ValidateSiteSessionRequest
 */
export interface ValidateSiteSessionRequest {
  /**
   *
   * @type {string}
   * @memberof ValidateSiteSessionRequest
   */
  siteId: string;
  /**
   *
   * @type {string}
   * @memberof ValidateSiteSessionRequest
   */
  token: string;
}
/**
 *
 * @export
 * @interface ValidateSiteSessionResponse
 */
export interface ValidateSiteSessionResponse {
  /**
   *
   * @type {string}
   * @memberof ValidateSiteSessionResponse
   */
  externalPlayerId: string;
  /**
   *
   * @type {number}
   * @memberof ValidateSiteSessionResponse
   */
  playerId: number;
}
/**
 * Verify phone
 * @export
 * @interface VerifyPhoneRequest
 */
export interface VerifyPhoneRequest {
  /**
   *
   * @type {string}
   * @memberof VerifyPhoneRequest
   */
  phonePin: string;
}
/**
 * Withdraw
 * @export
 * @interface WithdrawResponse
 */
export interface WithdrawResponse {
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  approvedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  approvedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  cancelledAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  executedAt?: string | null;
  /**
   *
   * @type {number}
   * @memberof WithdrawResponse
   */
  externalTransactionId?: number | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  faultedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  frozenAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  frozenByUserId?: string | null;
  /**
   *
   * @type {number}
   * @memberof WithdrawResponse
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  paymentProviderId: string;
  /**
   *
   * @type {number}
   * @memberof WithdrawResponse
   */
  playerId: number;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  reason?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  rejectedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  rejectedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  retriedAt?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  retriedByUserId?: string | null;
  /**
   *
   * @type {string}
   * @memberof WithdrawResponse
   */
  status: string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Sign-up new casino player via checkin
     * @summary Checkin Signup player
     * @param {CheckinSignupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkinSignup: async (body: CheckinSignupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('checkinSignup', 'body', body);
      const localVarPath = `/v1/auth/checkin/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Checkin validation enpoint
     * @summary Checkin Signup validation
     * @param {CheckinValidationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkinValidate: async (body: CheckinValidationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('checkinValidate', 'body', body);
      const localVarPath = `/v1/auth/checkin/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Confirm casino player token
     * @summary Confirm player token
     * @param {ConfirmTokenRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmToken: async (body: ConfirmTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('confirmToken', 'body', body);
      const localVarPath = `/v1/auth/confirmToken`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authenticate casino player
     * @summary Authenticate player
     * @param {LoginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (body: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('login', 'body', body);
      const localVarPath = `/v1/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sign-up new casino player
     * @summary Signup player
     * @param {SignupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup: async (body: SignupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('signup', 'body', body);
      const localVarPath = `/v1/auth/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     * Sign-up new casino player via checkin
     * @summary Checkin Signup player
     * @param {CheckinSignupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkinSignup(
      body: CheckinSignupRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSignup(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Checkin validation enpoint
     * @summary Checkin Signup validation
     * @param {CheckinValidationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkinValidate(
      body: CheckinValidationRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkinValidate(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Confirm casino player token
     * @summary Confirm player token
     * @param {ConfirmTokenRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmToken(
      body: ConfirmTokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirmToken(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authenticate casino player
     * @summary Authenticate player
     * @param {LoginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      body: LoginRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Sign-up new casino player
     * @summary Signup player
     * @param {SignupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signup(
      body: SignupRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signup(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthenticationApiFp(configuration);
  return {
    /**
     * Sign-up new casino player via checkin
     * @summary Checkin Signup player
     * @param {CheckinSignupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkinSignup(body: CheckinSignupRequest, options?: any): AxiosPromise<SignupResponse> {
      return localVarFp.checkinSignup(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Checkin validation enpoint
     * @summary Checkin Signup validation
     * @param {CheckinValidationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkinValidate(body: CheckinValidationRequest, options?: any): AxiosPromise<void> {
      return localVarFp.checkinValidate(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Confirm casino player token
     * @summary Confirm player token
     * @param {ConfirmTokenRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmToken(body: ConfirmTokenRequest, options?: any): AxiosPromise<ConfirmTokenResponse> {
      return localVarFp.confirmToken(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authenticate casino player
     * @summary Authenticate player
     * @param {LoginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(body: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
      return localVarFp.login(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Sign-up new casino player
     * @summary Signup player
     * @param {SignupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup(body: SignupRequest, options?: any): AxiosPromise<SignupResponse> {
      return localVarFp.signup(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   * Sign-up new casino player via checkin
   * @summary Checkin Signup player
   * @param {CheckinSignupRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public checkinSignup(body: CheckinSignupRequest, options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .checkinSignup(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Checkin validation enpoint
   * @summary Checkin Signup validation
   * @param {CheckinValidationRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public checkinValidate(body: CheckinValidationRequest, options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .checkinValidate(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Confirm casino player token
   * @summary Confirm player token
   * @param {ConfirmTokenRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public confirmToken(body: ConfirmTokenRequest, options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .confirmToken(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authenticate casino player
   * @summary Authenticate player
   * @param {LoginRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public login(body: LoginRequest, options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .login(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sign-up new casino player
   * @summary Signup player
   * @param {SignupRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public signup(body: SignupRequest, options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .signup(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DbApi - axios parameter creator
 * @export
 */
export const DbApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get casino player details
     * @summary Get player info
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dbGetPlayer: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('dbGetPlayer', 'id', id);
      const localVarPath = `/v1/db/players/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DbApi - functional programming interface
 * @export
 */
export const DbApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DbApiAxiosParamCreator(configuration);
  return {
    /**
     * Get casino player details
     * @summary Get player info
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dbGetPlayer(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DBPlayer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dbGetPlayer(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DbApi - factory interface
 * @export
 */
export const DbApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DbApiFp(configuration);
  return {
    /**
     * Get casino player details
     * @summary Get player info
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dbGetPlayer(id: number, options?: any): AxiosPromise<DBPlayer> {
      return localVarFp.dbGetPlayer(id, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * DbApi - object-oriented interface
 * @export
 * @class DbApi
 * @extends {BaseAPI}
 */
export class DbApi extends BaseAPI {
  /**
   * Get casino player details
   * @summary Get player info
   * @param {number} id Player internal ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DbApi
   */
  public dbGetPlayer(id: number, options?: AxiosRequestConfig) {
    return DbApiFp(this.configuration)
      .dbGetPlayer(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DummygamingApi - axios parameter creator
 * @export
 */
export const DummygamingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} token
     * @param {number} game
     * @param {string} roundId
     * @param {string} [betAmount]
     * @param {string} [amount]
     * @param {string} [type]
     * @param {boolean} [roundEnded]
     * @param {string} [freespinId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummygamingEventPost: async (
      token: string,
      game: number,
      roundId: string,
      betAmount?: string,
      amount?: string,
      type?: string,
      roundEnded?: boolean,
      freespinId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('dummygamingEventPost', 'token', token);
      // verify required parameter 'game' is not null or undefined
      assertParamExists('dummygamingEventPost', 'game', game);
      // verify required parameter 'roundId' is not null or undefined
      assertParamExists('dummygamingEventPost', 'roundId', roundId);
      const localVarPath = `/dummygaming/event`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      if (betAmount !== undefined) {
        localVarFormParams.set('betAmount', betAmount as any);
      }

      if (amount !== undefined) {
        localVarFormParams.set('amount', amount as any);
      }

      if (type !== undefined) {
        localVarFormParams.set('type', type as any);
      }

      if (game !== undefined) {
        localVarFormParams.set('game', game as any);
      }

      if (roundId !== undefined) {
        localVarFormParams.set('roundId', roundId as any);
      }

      if (roundEnded !== undefined) {
        localVarFormParams.set('roundEnded', roundEnded as any);
      }

      if (freespinId !== undefined) {
        localVarFormParams.set('freespinId', freespinId as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} siteId
     * @param {string} currencyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummygamingGameDemoSiteIdCurrencyIdGet: async (
      siteId: string,
      currencyId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'siteId' is not null or undefined
      assertParamExists('dummygamingGameDemoSiteIdCurrencyIdGet', 'siteId', siteId);
      // verify required parameter 'currencyId' is not null or undefined
      assertParamExists('dummygamingGameDemoSiteIdCurrencyIdGet', 'currencyId', currencyId);
      const localVarPath = `/dummygaming/game-demo/{siteId}/{currencyId}`
        .replace(`{${'siteId'}}`, encodeURIComponent(String(siteId)))
        .replace(`{${'currencyId'}}`, encodeURIComponent(String(currencyId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} siteId
     * @param {string} email
     * @param {string} password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummygamingGameDemoSiteIdEmailPasswordV1Get: async (
      siteId: string,
      email: string,
      password: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'siteId' is not null or undefined
      assertParamExists('dummygamingGameDemoSiteIdEmailPasswordV1Get', 'siteId', siteId);
      // verify required parameter 'email' is not null or undefined
      assertParamExists('dummygamingGameDemoSiteIdEmailPasswordV1Get', 'email', email);
      // verify required parameter 'password' is not null or undefined
      assertParamExists('dummygamingGameDemoSiteIdEmailPasswordV1Get', 'password', password);
      const localVarPath = `/dummygaming/game-demo/{siteId}/{email}/{password}/v1`
        .replace(`{${'siteId'}}`, encodeURIComponent(String(siteId)))
        .replace(`{${'email'}}`, encodeURIComponent(String(email)))
        .replace(`{${'password'}}`, encodeURIComponent(String(password)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} token
     * @param {number} playerId
     * @param {number} bonusId
     * @param {string} [initialReward]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummygamingManualbonusPost: async (
      token: string,
      playerId: number,
      bonusId: number,
      initialReward?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('dummygamingManualbonusPost', 'token', token);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('dummygamingManualbonusPost', 'playerId', playerId);
      // verify required parameter 'bonusId' is not null or undefined
      assertParamExists('dummygamingManualbonusPost', 'bonusId', bonusId);
      const localVarPath = `/dummygaming/manualbonus`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      if (playerId !== undefined) {
        localVarFormParams.set('playerId', playerId as any);
      }

      if (initialReward !== undefined) {
        localVarFormParams.set('initialReward', initialReward as any);
      }

      if (bonusId !== undefined) {
        localVarFormParams.set('bonusId', bonusId as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DummygamingApi - functional programming interface
 * @export
 */
export const DummygamingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DummygamingApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} token
     * @param {number} game
     * @param {string} roundId
     * @param {string} [betAmount]
     * @param {string} [amount]
     * @param {string} [type]
     * @param {boolean} [roundEnded]
     * @param {string} [freespinId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dummygamingEventPost(
      token: string,
      game: number,
      roundId: string,
      betAmount?: string,
      amount?: string,
      type?: string,
      roundEnded?: boolean,
      freespinId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dummygamingEventPost(
        token,
        game,
        roundId,
        betAmount,
        amount,
        type,
        roundEnded,
        freespinId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} siteId
     * @param {string} currencyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dummygamingGameDemoSiteIdCurrencyIdGet(
      siteId: string,
      currencyId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dummygamingGameDemoSiteIdCurrencyIdGet(
        siteId,
        currencyId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} siteId
     * @param {string} email
     * @param {string} password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dummygamingGameDemoSiteIdEmailPasswordV1Get(
      siteId: string,
      email: string,
      password: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dummygamingGameDemoSiteIdEmailPasswordV1Get(
        siteId,
        email,
        password,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} token
     * @param {number} playerId
     * @param {number} bonusId
     * @param {string} [initialReward]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dummygamingManualbonusPost(
      token: string,
      playerId: number,
      bonusId: number,
      initialReward?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dummygamingManualbonusPost(
        token,
        playerId,
        bonusId,
        initialReward,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DummygamingApi - factory interface
 * @export
 */
export const DummygamingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DummygamingApiFp(configuration);
  return {
    /**
     *
     * @param {string} token
     * @param {number} game
     * @param {string} roundId
     * @param {string} [betAmount]
     * @param {string} [amount]
     * @param {string} [type]
     * @param {boolean} [roundEnded]
     * @param {string} [freespinId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummygamingEventPost(
      token: string,
      game: number,
      roundId: string,
      betAmount?: string,
      amount?: string,
      type?: string,
      roundEnded?: boolean,
      freespinId?: string,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .dummygamingEventPost(token, game, roundId, betAmount, amount, type, roundEnded, freespinId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} siteId
     * @param {string} currencyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummygamingGameDemoSiteIdCurrencyIdGet(siteId: string, currencyId: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .dummygamingGameDemoSiteIdCurrencyIdGet(siteId, currencyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} siteId
     * @param {string} email
     * @param {string} password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummygamingGameDemoSiteIdEmailPasswordV1Get(
      siteId: string,
      email: string,
      password: string,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .dummygamingGameDemoSiteIdEmailPasswordV1Get(siteId, email, password, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} token
     * @param {number} playerId
     * @param {number} bonusId
     * @param {string} [initialReward]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummygamingManualbonusPost(
      token: string,
      playerId: number,
      bonusId: number,
      initialReward?: string,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .dummygamingManualbonusPost(token, playerId, bonusId, initialReward, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DummygamingApi - object-oriented interface
 * @export
 * @class DummygamingApi
 * @extends {BaseAPI}
 */
export class DummygamingApi extends BaseAPI {
  /**
   *
   * @param {string} token
   * @param {number} game
   * @param {string} roundId
   * @param {string} [betAmount]
   * @param {string} [amount]
   * @param {string} [type]
   * @param {boolean} [roundEnded]
   * @param {string} [freespinId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DummygamingApi
   */
  public dummygamingEventPost(
    token: string,
    game: number,
    roundId: string,
    betAmount?: string,
    amount?: string,
    type?: string,
    roundEnded?: boolean,
    freespinId?: string,
    options?: AxiosRequestConfig,
  ) {
    return DummygamingApiFp(this.configuration)
      .dummygamingEventPost(token, game, roundId, betAmount, amount, type, roundEnded, freespinId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} siteId
   * @param {string} currencyId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DummygamingApi
   */
  public dummygamingGameDemoSiteIdCurrencyIdGet(siteId: string, currencyId: string, options?: AxiosRequestConfig) {
    return DummygamingApiFp(this.configuration)
      .dummygamingGameDemoSiteIdCurrencyIdGet(siteId, currencyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} siteId
   * @param {string} email
   * @param {string} password
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DummygamingApi
   */
  public dummygamingGameDemoSiteIdEmailPasswordV1Get(
    siteId: string,
    email: string,
    password: string,
    options?: AxiosRequestConfig,
  ) {
    return DummygamingApiFp(this.configuration)
      .dummygamingGameDemoSiteIdEmailPasswordV1Get(siteId, email, password, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} token
   * @param {number} playerId
   * @param {number} bonusId
   * @param {string} [initialReward]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DummygamingApi
   */
  public dummygamingManualbonusPost(
    token: string,
    playerId: number,
    bonusId: number,
    initialReward?: string,
    options?: AxiosRequestConfig,
  ) {
    return DummygamingApiFp(this.configuration)
      .dummygamingManualbonusPost(token, playerId, bonusId, initialReward, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FreespinsApi - axios parameter creator
 * @export
 */
export const FreespinsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Freespin Activate
     * @summary Freespin Activate
     * @param {string} operatorID Operator ID
     * @param {FreespinActivateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freespinActivate: async (
      operatorID: string,
      body: FreespinActivateRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists('freespinActivate', 'operatorID', operatorID);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('freespinActivate', 'body', body);
      const localVarPath = `/v1/{operatorID}/freespin/activate`.replace(
        `{${'operatorID'}}`,
        encodeURIComponent(String(operatorID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * freespin Cancel
     * @summary freespin Cancel
     * @param {string} operatorID Operator ID
     * @param {FreespinCancelRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freespinCancel: async (
      operatorID: string,
      body: FreespinCancelRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists('freespinCancel', 'operatorID', operatorID);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('freespinCancel', 'body', body);
      const localVarPath = `/v1/{operatorID}/freespin/cancel`.replace(
        `{${'operatorID'}}`,
        encodeURIComponent(String(operatorID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Freespin Get
     * @summary Freespin Get
     * @param {string} operatorID Operator ID
     * @param {string} freespinID FreespinID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freespinGet: async (
      operatorID: string,
      freespinID: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists('freespinGet', 'operatorID', operatorID);
      // verify required parameter 'freespinID' is not null or undefined
      assertParamExists('freespinGet', 'freespinID', freespinID);
      const localVarPath = `/v1/{operatorID}/freespin/{freespinID}`
        .replace(`{${'operatorID'}}`, encodeURIComponent(String(operatorID)))
        .replace(`{${'freespinID'}}`, encodeURIComponent(String(freespinID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Freespin Bets
     * @summary Freespin Bets
     * @param {string} operatorID Operator ID
     * @param {FreespinBetsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freespinOptions: async (
      operatorID: string,
      body: FreespinBetsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists('freespinOptions', 'operatorID', operatorID);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('freespinOptions', 'body', body);
      const localVarPath = `/v1/{operatorID}/freespin/bets`.replace(
        `{${'operatorID'}}`,
        encodeURIComponent(String(operatorID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FreespinsApi - functional programming interface
 * @export
 */
export const FreespinsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FreespinsApiAxiosParamCreator(configuration);
  return {
    /**
     * Freespin Activate
     * @summary Freespin Activate
     * @param {string} operatorID Operator ID
     * @param {FreespinActivateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async freespinActivate(
      operatorID: string,
      body: FreespinActivateRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreespinActivatedResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.freespinActivate(operatorID, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * freespin Cancel
     * @summary freespin Cancel
     * @param {string} operatorID Operator ID
     * @param {FreespinCancelRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async freespinCancel(
      operatorID: string,
      body: FreespinCancelRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.freespinCancel(operatorID, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Freespin Get
     * @summary Freespin Get
     * @param {string} operatorID Operator ID
     * @param {string} freespinID FreespinID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async freespinGet(
      operatorID: string,
      freespinID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreespinGetResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.freespinGet(operatorID, freespinID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Freespin Bets
     * @summary Freespin Bets
     * @param {string} operatorID Operator ID
     * @param {FreespinBetsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async freespinOptions(
      operatorID: string,
      body: FreespinBetsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreespinBetsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.freespinOptions(operatorID, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FreespinsApi - factory interface
 * @export
 */
export const FreespinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FreespinsApiFp(configuration);
  return {
    /**
     * Freespin Activate
     * @summary Freespin Activate
     * @param {string} operatorID Operator ID
     * @param {FreespinActivateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freespinActivate(
      operatorID: string,
      body: FreespinActivateRequest,
      options?: any,
    ): AxiosPromise<FreespinActivatedResponse> {
      return localVarFp.freespinActivate(operatorID, body, options).then((request) => request(axios, basePath));
    },
    /**
     * freespin Cancel
     * @summary freespin Cancel
     * @param {string} operatorID Operator ID
     * @param {FreespinCancelRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freespinCancel(operatorID: string, body: FreespinCancelRequest, options?: any): AxiosPromise<void> {
      return localVarFp.freespinCancel(operatorID, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Freespin Get
     * @summary Freespin Get
     * @param {string} operatorID Operator ID
     * @param {string} freespinID FreespinID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freespinGet(operatorID: string, freespinID: string, options?: any): AxiosPromise<FreespinGetResponse> {
      return localVarFp.freespinGet(operatorID, freespinID, options).then((request) => request(axios, basePath));
    },
    /**
     * Freespin Bets
     * @summary Freespin Bets
     * @param {string} operatorID Operator ID
     * @param {FreespinBetsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freespinOptions(operatorID: string, body: FreespinBetsRequest, options?: any): AxiosPromise<FreespinBetsResponse> {
      return localVarFp.freespinOptions(operatorID, body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * FreespinsApi - object-oriented interface
 * @export
 * @class FreespinsApi
 * @extends {BaseAPI}
 */
export class FreespinsApi extends BaseAPI {
  /**
   * Freespin Activate
   * @summary Freespin Activate
   * @param {string} operatorID Operator ID
   * @param {FreespinActivateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FreespinsApi
   */
  public freespinActivate(operatorID: string, body: FreespinActivateRequest, options?: AxiosRequestConfig) {
    return FreespinsApiFp(this.configuration)
      .freespinActivate(operatorID, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * freespin Cancel
   * @summary freespin Cancel
   * @param {string} operatorID Operator ID
   * @param {FreespinCancelRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FreespinsApi
   */
  public freespinCancel(operatorID: string, body: FreespinCancelRequest, options?: AxiosRequestConfig) {
    return FreespinsApiFp(this.configuration)
      .freespinCancel(operatorID, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Freespin Get
   * @summary Freespin Get
   * @param {string} operatorID Operator ID
   * @param {string} freespinID FreespinID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FreespinsApi
   */
  public freespinGet(operatorID: string, freespinID: string, options?: AxiosRequestConfig) {
    return FreespinsApiFp(this.configuration)
      .freespinGet(operatorID, freespinID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Freespin Bets
   * @summary Freespin Bets
   * @param {string} operatorID Operator ID
   * @param {FreespinBetsRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FreespinsApi
   */
  public freespinOptions(operatorID: string, body: FreespinBetsRequest, options?: AxiosRequestConfig) {
    return FreespinsApiFp(this.configuration)
      .freespinOptions(operatorID, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GamesApi - axios parameter creator
 * @export
 */
export const GamesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * PragmaticPlay Demo Game
     * @summary PragmaticPlay Demo Game
     * @param {PragmaticplayDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayDemoGame: async (
      body: PragmaticplayDemoGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('pragmaticPlayDemoGame', 'body', body);
      const localVarPath = `/v1/games/game/demo/pragmaticplay`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Start PragmaticPlay game
     * @summary Start PragmaticPlay game
     * @param {PragmaticplayStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticplayStartGame: async (
      body: PragmaticplayStartGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('pragmaticplayStartGame', 'body', body);
      const localVarPath = `/v1/games/game/start/pragmaticplay`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Slotegrator Demo Game
     * @summary Slotegrator Demo Game
     * @param {SlotegratorDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorDemoGame: async (
      body: SlotegratorDemoGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('slotegratorDemoGame', 'body', body);
      const localVarPath = `/v1/games/game/demo/slotegrator`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Start Slotegrator game
     * @summary Start Slotegrator game
     * @param {SlotegratorStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorStartGame: async (
      body: SlotegratorStartGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('slotegratorStartGame', 'body', body);
      const localVarPath = `/v1/games/game/start/slotegrator`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Softswiss Demo Game
     * @summary Softswiss Demo Game
     * @param {SoftSwissDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softswissDemoGame: async (
      body: SoftSwissDemoGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('softswissDemoGame', 'body', body);
      const localVarPath = `/v1/games/game/demo/softswiss`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Start Softswiss game
     * @summary Start Softswiss game
     * @param {SoftSwissStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softswissStartGame: async (
      body: SoftSwissStartGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('softswissStartGame', 'body', body);
      const localVarPath = `/v1/games/game/start/softswiss`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a User and Start a Game
     * @summary Create a User and Start a Game
     * @param {string} operatorID Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testOperatorGame: async (operatorID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists('testOperatorGame', 'operatorID', operatorID);
      const localVarPath = `/v1/games/game/operator/{operatorID}/test`.replace(
        `{${'operatorID'}}`,
        encodeURIComponent(String(operatorID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a User and Start a Game
     * @summary Create a User and Start a Game
     * @param {string} operatorID Operator ID
     * @param {number} gameID game internal id
     * @param {number} quantity Number of freespins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testOperatorGameFreespin: async (
      operatorID: string,
      gameID: number,
      quantity: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatorID' is not null or undefined
      assertParamExists('testOperatorGameFreespin', 'operatorID', operatorID);
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('testOperatorGameFreespin', 'gameID', gameID);
      // verify required parameter 'quantity' is not null or undefined
      assertParamExists('testOperatorGameFreespin', 'quantity', quantity);
      const localVarPath = `/v1/games/game/operator/{operatorID}/test/{gameID}/freespin/{quantity}/`
        .replace(`{${'operatorID'}}`, encodeURIComponent(String(operatorID)))
        .replace(`{${'gameID'}}`, encodeURIComponent(String(gameID)))
        .replace(`{${'quantity'}}`, encodeURIComponent(String(quantity)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GamesApi - functional programming interface
 * @export
 */
export const GamesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GamesApiAxiosParamCreator(configuration);
  return {
    /**
     * PragmaticPlay Demo Game
     * @summary PragmaticPlay Demo Game
     * @param {PragmaticplayDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticPlayDemoGame(
      body: PragmaticplayDemoGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticplayDemoGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticPlayDemoGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Start PragmaticPlay game
     * @summary Start PragmaticPlay game
     * @param {PragmaticplayStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticplayStartGame(
      body: PragmaticplayStartGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticplayStartGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticplayStartGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Slotegrator Demo Game
     * @summary Slotegrator Demo Game
     * @param {SlotegratorDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slotegratorDemoGame(
      body: SlotegratorDemoGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlotegratorDemoGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slotegratorDemoGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Start Slotegrator game
     * @summary Start Slotegrator game
     * @param {SlotegratorStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slotegratorStartGame(
      body: SlotegratorStartGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlotegratorStartGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slotegratorStartGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Softswiss Demo Game
     * @summary Softswiss Demo Game
     * @param {SoftSwissDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async softswissDemoGame(
      body: SoftSwissDemoGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftSwissDemoGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.softswissDemoGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Start Softswiss game
     * @summary Start Softswiss game
     * @param {SoftSwissStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async softswissStartGame(
      body: SoftSwissStartGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftSwissStartGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.softswissStartGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a User and Start a Game
     * @summary Create a User and Start a Game
     * @param {string} operatorID Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async testOperatorGame(
      operatorID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.testOperatorGame(operatorID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a User and Start a Game
     * @summary Create a User and Start a Game
     * @param {string} operatorID Operator ID
     * @param {number} gameID game internal id
     * @param {number} quantity Number of freespins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async testOperatorGameFreespin(
      operatorID: string,
      gameID: number,
      quantity: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.testOperatorGameFreespin(
        operatorID,
        gameID,
        quantity,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * GamesApi - factory interface
 * @export
 */
export const GamesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GamesApiFp(configuration);
  return {
    /**
     * PragmaticPlay Demo Game
     * @summary PragmaticPlay Demo Game
     * @param {PragmaticplayDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayDemoGame(
      body: PragmaticplayDemoGameRequest,
      options?: any,
    ): AxiosPromise<PragmaticplayDemoGameResponse> {
      return localVarFp.pragmaticPlayDemoGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Start PragmaticPlay game
     * @summary Start PragmaticPlay game
     * @param {PragmaticplayStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticplayStartGame(
      body: PragmaticplayStartGameRequest,
      options?: any,
    ): AxiosPromise<PragmaticplayStartGameResponse> {
      return localVarFp.pragmaticplayStartGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Slotegrator Demo Game
     * @summary Slotegrator Demo Game
     * @param {SlotegratorDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorDemoGame(body: SlotegratorDemoGameRequest, options?: any): AxiosPromise<SlotegratorDemoGameResponse> {
      return localVarFp.slotegratorDemoGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Start Slotegrator game
     * @summary Start Slotegrator game
     * @param {SlotegratorStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorStartGame(body: SlotegratorStartGameRequest, options?: any): AxiosPromise<SlotegratorStartGameResponse> {
      return localVarFp.slotegratorStartGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Softswiss Demo Game
     * @summary Softswiss Demo Game
     * @param {SoftSwissDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softswissDemoGame(body: SoftSwissDemoGameRequest, options?: any): AxiosPromise<SoftSwissDemoGameResponse> {
      return localVarFp.softswissDemoGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Start Softswiss game
     * @summary Start Softswiss game
     * @param {SoftSwissStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softswissStartGame(body: SoftSwissStartGameRequest, options?: any): AxiosPromise<SoftSwissStartGameResponse> {
      return localVarFp.softswissStartGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Create a User and Start a Game
     * @summary Create a User and Start a Game
     * @param {string} operatorID Operator ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testOperatorGame(operatorID: string, options?: any): AxiosPromise<string> {
      return localVarFp.testOperatorGame(operatorID, options).then((request) => request(axios, basePath));
    },
    /**
     * Create a User and Start a Game
     * @summary Create a User and Start a Game
     * @param {string} operatorID Operator ID
     * @param {number} gameID game internal id
     * @param {number} quantity Number of freespins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testOperatorGameFreespin(
      operatorID: string,
      gameID: number,
      quantity: number,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .testOperatorGameFreespin(operatorID, gameID, quantity, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GamesApi - object-oriented interface
 * @export
 * @class GamesApi
 * @extends {BaseAPI}
 */
export class GamesApi extends BaseAPI {
  /**
   * PragmaticPlay Demo Game
   * @summary PragmaticPlay Demo Game
   * @param {PragmaticplayDemoGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GamesApi
   */
  public pragmaticPlayDemoGame(body: PragmaticplayDemoGameRequest, options?: AxiosRequestConfig) {
    return GamesApiFp(this.configuration)
      .pragmaticPlayDemoGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Start PragmaticPlay game
   * @summary Start PragmaticPlay game
   * @param {PragmaticplayStartGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GamesApi
   */
  public pragmaticplayStartGame(body: PragmaticplayStartGameRequest, options?: AxiosRequestConfig) {
    return GamesApiFp(this.configuration)
      .pragmaticplayStartGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Slotegrator Demo Game
   * @summary Slotegrator Demo Game
   * @param {SlotegratorDemoGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GamesApi
   */
  public slotegratorDemoGame(body: SlotegratorDemoGameRequest, options?: AxiosRequestConfig) {
    return GamesApiFp(this.configuration)
      .slotegratorDemoGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Start Slotegrator game
   * @summary Start Slotegrator game
   * @param {SlotegratorStartGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GamesApi
   */
  public slotegratorStartGame(body: SlotegratorStartGameRequest, options?: AxiosRequestConfig) {
    return GamesApiFp(this.configuration)
      .slotegratorStartGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Softswiss Demo Game
   * @summary Softswiss Demo Game
   * @param {SoftSwissDemoGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GamesApi
   */
  public softswissDemoGame(body: SoftSwissDemoGameRequest, options?: AxiosRequestConfig) {
    return GamesApiFp(this.configuration)
      .softswissDemoGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Start Softswiss game
   * @summary Start Softswiss game
   * @param {SoftSwissStartGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GamesApi
   */
  public softswissStartGame(body: SoftSwissStartGameRequest, options?: AxiosRequestConfig) {
    return GamesApiFp(this.configuration)
      .softswissStartGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a User and Start a Game
   * @summary Create a User and Start a Game
   * @param {string} operatorID Operator ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GamesApi
   */
  public testOperatorGame(operatorID: string, options?: AxiosRequestConfig) {
    return GamesApiFp(this.configuration)
      .testOperatorGame(operatorID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a User and Start a Game
   * @summary Create a User and Start a Game
   * @param {string} operatorID Operator ID
   * @param {number} gameID game internal id
   * @param {number} quantity Number of freespins
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GamesApi
   */
  public testOperatorGameFreespin(operatorID: string, gameID: number, quantity: number, options?: AxiosRequestConfig) {
    return GamesApiFp(this.configuration)
      .testOperatorGameFreespin(operatorID, gameID, quantity, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get list of application codes
     * @summary Get List of Application Codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppCodes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/app-codes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GeneralApiAxiosParamCreator(configuration);
  return {
    /**
     * Get list of application codes
     * @summary Get List of Application Codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppCodes(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppMessage>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppCodes(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GeneralApiFp(configuration);
  return {
    /**
     * Get list of application codes
     * @summary Get List of Application Codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppCodes(options?: any): AxiosPromise<Array<AppMessage>> {
      return localVarFp.getAppCodes(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI {
  /**
   * Get list of application codes
   * @summary Get List of Application Codes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneralApi
   */
  public getAppCodes(options?: AxiosRequestConfig) {
    return GeneralApiFp(this.configuration)
      .getAppCodes(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Liveness Probe
     * @summary Liveness Probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLivenessProbe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/_livenessProbe`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Readiness Probe
     * @summary Readiness Probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReadinessProbe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/_readinessProbe`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     * Liveness Probe
     * @summary Liveness Probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLivenessProbe(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivenessProbe>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLivenessProbe(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Readiness Probe
     * @summary Readiness Probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReadinessProbe(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReadinessProbe(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     * Liveness Probe
     * @summary Liveness Probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLivenessProbe(options?: any): AxiosPromise<LivenessProbe> {
      return localVarFp.getLivenessProbe(options).then((request) => request(axios, basePath));
    },
    /**
     * Readiness Probe
     * @summary Readiness Probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReadinessProbe(options?: any): AxiosPromise<void> {
      return localVarFp.getReadinessProbe(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * Liveness Probe
   * @summary Liveness Probe
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getLivenessProbe(options?: AxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .getLivenessProbe(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Readiness Probe
   * @summary Readiness Probe
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getReadinessProbe(options?: AxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .getReadinessProbe(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PlayerApi - axios parameter creator
 * @export
 */
export const PlayerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete game from favorites
     * @param {number} id Player internal ID
     * @param {number} gameID game internal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1PlayersIdFavoriteGamesGameIDDelete: async (
      id: number,
      gameID: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('v1PlayersIdFavoriteGamesGameIDDelete', 'id', id);
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('v1PlayersIdFavoriteGamesGameIDDelete', 'gameID', gameID);
      const localVarPath = `/v1/players/{id}/favorite-games/{gameID}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'gameID'}}`, encodeURIComponent(String(gameID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add game to favorite
     * @param {number} id Player internal ID
     * @param {number} gameID game internal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1PlayersIdFavoriteGamesGameIDPost: async (
      id: number,
      gameID: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('v1PlayersIdFavoriteGamesGameIDPost', 'id', id);
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('v1PlayersIdFavoriteGamesGameIDPost', 'gameID', gameID);
      const localVarPath = `/v1/players/{id}/favorite-games/{gameID}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'gameID'}}`, encodeURIComponent(String(gameID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlayerApi - functional programming interface
 * @export
 */
export const PlayerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PlayerApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete game from favorites
     * @param {number} id Player internal ID
     * @param {number} gameID game internal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1PlayersIdFavoriteGamesGameIDDelete(
      id: number,
      gameID: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlayersIdFavoriteGamesGameIDDelete(
        id,
        gameID,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Add game to favorite
     * @param {number} id Player internal ID
     * @param {number} gameID game internal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1PlayersIdFavoriteGamesGameIDPost(
      id: number,
      gameID: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlayersIdFavoriteGamesGameIDPost(id, gameID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PlayerApi - factory interface
 * @export
 */
export const PlayerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PlayerApiFp(configuration);
  return {
    /**
     * Delete game from favorites
     * @param {number} id Player internal ID
     * @param {number} gameID game internal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1PlayersIdFavoriteGamesGameIDDelete(id: number, gameID: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .v1PlayersIdFavoriteGamesGameIDDelete(id, gameID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add game to favorite
     * @param {number} id Player internal ID
     * @param {number} gameID game internal id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1PlayersIdFavoriteGamesGameIDPost(id: number, gameID: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .v1PlayersIdFavoriteGamesGameIDPost(id, gameID, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PlayerApi - object-oriented interface
 * @export
 * @class PlayerApi
 * @extends {BaseAPI}
 */
export class PlayerApi extends BaseAPI {
  /**
   * Delete game from favorites
   * @param {number} id Player internal ID
   * @param {number} gameID game internal id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerApi
   */
  public v1PlayersIdFavoriteGamesGameIDDelete(id: number, gameID: number, options?: AxiosRequestConfig) {
    return PlayerApiFp(this.configuration)
      .v1PlayersIdFavoriteGamesGameIDDelete(id, gameID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add game to favorite
   * @param {number} id Player internal ID
   * @param {number} gameID game internal id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerApi
   */
  public v1PlayersIdFavoriteGamesGameIDPost(id: number, gameID: number, options?: AxiosRequestConfig) {
    return PlayerApiFp(this.configuration)
      .v1PlayersIdFavoriteGamesGameIDPost(id, gameID, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PlayersApi - axios parameter creator
 * @export
 */
export const PlayersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Acknowledge terms on player behalf
     * @summary Acknowledge casino terms
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acknowledgeCasinoTerms: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('acknowledgeCasinoTerms', 'id', id);
      const localVarPath = `/v1/players/{id}/acknowledgeTerms`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add game to player favourities list
     * @summary Add game to player favourities list
     * @param {number} id Player internal ID
     * @param {GameFavouritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPlayerGameFavourites: async (
      id: number,
      body: GameFavouritesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('addPlayerGameFavourites', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('addPlayerGameFavourites', 'body', body);
      const localVarPath = `/v1/players/{id}/games/favourites`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * cancelBonus
     * @param {number} id Player internal ID
     * @param {CancelPlayerBonusRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBonus: async (
      id: number,
      payload: CancelPlayerBonusRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('cancelBonus', 'id', id);
      // verify required parameter 'payload' is not null or undefined
      assertParamExists('cancelBonus', 'payload', payload);
      const localVarPath = `/v1/players/{id}/cancelBonus`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Change personal information
     * @summary Change personal information
     * @param {number} id Player internal ID
     * @param {ChangePersonalInformationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePersonalInformation: async (
      id: number,
      body: ChangePersonalInformationRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('changePersonalInformation', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('changePersonalInformation', 'body', body);
      const localVarPath = `/v1/players/{id}/changePersonalInformation`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Change player consents
     * @summary Change player consents
     * @param {number} id Player internal ID
     * @param {ChangePlayerConsentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePlayerConsents: async (
      id: number,
      body: ChangePlayerConsentsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('changePlayerConsents', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('changePlayerConsents', 'body', body);
      const localVarPath = `/v1/players/{id}/changeConsents`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Change casino player password
     * @summary Change player password
     * @param {number} id Player internal ID
     * @param {PlayerChangePasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePlayerPassword: async (
      id: number,
      body: PlayerChangePasswordRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('changePlayerPassword', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('changePlayerPassword', 'body', body);
      const localVarPath = `/v1/players/{id}/changePassword`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get casino player details
     * @summary Get player info
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayer: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPlayer', 'id', id);
      const localVarPath = `/v1/players/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get active bonus for the player
     * @summary Get player active bonuses
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerActivebonuses: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPlayerActivebonuses', 'id', id);
      const localVarPath = `/v1/players/{id}/activeBonuses`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get bonus campaigns available for the player
     * @summary Get player eligible bonuses
     * @param {number} id Player internal ID
     * @param {SearchPlayerEligibleBonusesRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerEligibleBonuses: async (
      id: number,
      payload: SearchPlayerEligibleBonusesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPlayerEligibleBonuses', 'id', id);
      // verify required parameter 'payload' is not null or undefined
      assertParamExists('getPlayerEligibleBonuses', 'payload', payload);
      const localVarPath = `/v1/players/{id}/eligibleBonuses`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get player game history
     * @summary Get player game history
     * @param {number} id Player internal ID
     * @param {SearchPlayerGameHistoryRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerGameHistory: async (
      id: number,
      payload: SearchPlayerGameHistoryRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPlayerGameHistory', 'id', id);
      // verify required parameter 'payload' is not null or undefined
      assertParamExists('getPlayerGameHistory', 'payload', payload);
      const localVarPath = `/v1/players/{id}/gamehistory`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Make deposit
     * @summary Make deposit
     * @param {number} id Player internal ID
     * @param {MakeDepositRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeDeposit: async (
      id: number,
      body: MakeDepositRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('makeDeposit', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('makeDeposit', 'body', body);
      const localVarPath = `/v1/players/{id}/deposit`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add game to player favourities list
     * @summary Add game to player favourities list
     * @param {number} id Player internal ID
     * @param {GameFavouritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePlayerGameFavourites: async (
      id: number,
      body: GameFavouritesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('removePlayerGameFavourites', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('removePlayerGameFavourites', 'body', body);
      const localVarPath = `/v1/players/{id}/games/favourites`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request Phone verification
     * @summary Request Phone verification
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPinVerification: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('requestPinVerification', 'id', id);
      const localVarPath = `/v1/players/{id}/mobile/requestPin`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Submit KYC application
     * @summary Resolve player KYC application
     * @param {number} id Player internal ID
     * @param {KycResolution} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveKycApplication: async (
      id: number,
      body: KycResolution,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('resolveKycApplication', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('resolveKycApplication', 'body', body);
      const localVarPath = `/v1/players/{id}/resolveKyc`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * StartBonus
     * @param {number} id Player internal ID
     * @param {StartPlayerBonusRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startBonus: async (
      id: number,
      payload: StartPlayerBonusRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('startBonus', 'id', id);
      // verify required parameter 'payload' is not null or undefined
      assertParamExists('startBonus', 'payload', payload);
      const localVarPath = `/v1/players/{id}/startBonus`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Submit KYC applications
     * @summary Submit KYC applications
     * @param {number} id Player internal ID
     * @param {Array<PlayerKycApplication>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitKycApplications: async (
      id: number,
      body: Array<PlayerKycApplication>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('submitKycApplications', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('submitKycApplications', 'body', body);
      const localVarPath = `/v1/players/{id}/submitKycApplications`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Verify Phone PIN request
     * @summary Verify Phone PIN request
     * @param {number} id Player internal ID
     * @param {VerifyPhoneRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPhoneVerification: async (
      id: number,
      body: VerifyPhoneRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('verifyPhoneVerification', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('verifyPhoneVerification', 'body', body);
      const localVarPath = `/v1/players/{id}/mobile/verifyPin`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PlayersApiAxiosParamCreator(configuration);
  return {
    /**
     * Acknowledge terms on player behalf
     * @summary Acknowledge casino terms
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async acknowledgeCasinoTerms(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.acknowledgeCasinoTerms(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Add game to player favourities list
     * @summary Add game to player favourities list
     * @param {number} id Player internal ID
     * @param {GameFavouritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPlayerGameFavourites(
      id: number,
      body: GameFavouritesRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameFavouritesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addPlayerGameFavourites(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * cancelBonus
     * @param {number} id Player internal ID
     * @param {CancelPlayerBonusRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelBonus(
      id: number,
      payload: CancelPlayerBonusRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBonus(id, payload, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Change personal information
     * @summary Change personal information
     * @param {number} id Player internal ID
     * @param {ChangePersonalInformationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePersonalInformation(
      id: number,
      body: ChangePersonalInformationRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerInfoResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePersonalInformation(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Change player consents
     * @summary Change player consents
     * @param {number} id Player internal ID
     * @param {ChangePlayerConsentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePlayerConsents(
      id: number,
      body: ChangePlayerConsentsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerInfoResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePlayerConsents(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Change casino player password
     * @summary Change player password
     * @param {number} id Player internal ID
     * @param {PlayerChangePasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePlayerPassword(
      id: number,
      body: PlayerChangePasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePlayerPassword(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get casino player details
     * @summary Get player info
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayer(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerInfoResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayer(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get active bonus for the player
     * @summary Get player active bonuses
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayerActivebonuses(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DBPlayerActiveCasinoBonuses>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerActivebonuses(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get bonus campaigns available for the player
     * @summary Get player eligible bonuses
     * @param {number} id Player internal ID
     * @param {SearchPlayerEligibleBonusesRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayerEligibleBonuses(
      id: number,
      payload: SearchPlayerEligibleBonusesRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerEligibleBonus>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerEligibleBonuses(id, payload, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get player game history
     * @summary Get player game history
     * @param {number} id Player internal ID
     * @param {SearchPlayerGameHistoryRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayerGameHistory(
      id: number,
      payload: SearchPlayerGameHistoryRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerGameHistoryRecord>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerGameHistory(id, payload, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Make deposit
     * @summary Make deposit
     * @param {number} id Player internal ID
     * @param {MakeDepositRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeDeposit(
      id: number,
      body: MakeDepositRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposit>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.makeDeposit(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Add game to player favourities list
     * @summary Add game to player favourities list
     * @param {number} id Player internal ID
     * @param {GameFavouritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePlayerGameFavourites(
      id: number,
      body: GameFavouritesRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePlayerGameFavourites(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Request Phone verification
     * @summary Request Phone verification
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestPinVerification(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestPinVerification(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Submit KYC application
     * @summary Resolve player KYC application
     * @param {number} id Player internal ID
     * @param {KycResolution} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resolveKycApplication(
      id: number,
      body: KycResolution,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resolveKycApplication(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * StartBonus
     * @param {number} id Player internal ID
     * @param {StartPlayerBonusRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startBonus(
      id: number,
      payload: StartPlayerBonusRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startBonus(id, payload, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Submit KYC applications
     * @summary Submit KYC applications
     * @param {number} id Player internal ID
     * @param {Array<PlayerKycApplication>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitKycApplications(
      id: number,
      body: Array<PlayerKycApplication>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitKycApplications(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Verify Phone PIN request
     * @summary Verify Phone PIN request
     * @param {number} id Player internal ID
     * @param {VerifyPhoneRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyPhoneVerification(
      id: number,
      body: VerifyPhoneRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerInfoResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifyPhoneVerification(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PlayersApiFp(configuration);
  return {
    /**
     * Acknowledge terms on player behalf
     * @summary Acknowledge casino terms
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acknowledgeCasinoTerms(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.acknowledgeCasinoTerms(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Add game to player favourities list
     * @summary Add game to player favourities list
     * @param {number} id Player internal ID
     * @param {GameFavouritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPlayerGameFavourites(
      id: number,
      body: GameFavouritesRequest,
      options?: any,
    ): AxiosPromise<GameFavouritesResponse> {
      return localVarFp.addPlayerGameFavourites(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * cancelBonus
     * @param {number} id Player internal ID
     * @param {CancelPlayerBonusRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBonus(id: number, payload: CancelPlayerBonusRequest, options?: any): AxiosPromise<void> {
      return localVarFp.cancelBonus(id, payload, options).then((request) => request(axios, basePath));
    },
    /**
     * Change personal information
     * @summary Change personal information
     * @param {number} id Player internal ID
     * @param {ChangePersonalInformationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePersonalInformation(
      id: number,
      body: ChangePersonalInformationRequest,
      options?: any,
    ): AxiosPromise<PlayerInfoResponse> {
      return localVarFp.changePersonalInformation(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Change player consents
     * @summary Change player consents
     * @param {number} id Player internal ID
     * @param {ChangePlayerConsentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePlayerConsents(
      id: number,
      body: ChangePlayerConsentsRequest,
      options?: any,
    ): AxiosPromise<PlayerInfoResponse> {
      return localVarFp.changePlayerConsents(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Change casino player password
     * @summary Change player password
     * @param {number} id Player internal ID
     * @param {PlayerChangePasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePlayerPassword(id: number, body: PlayerChangePasswordRequest, options?: any): AxiosPromise<void> {
      return localVarFp.changePlayerPassword(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Get casino player details
     * @summary Get player info
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayer(id: number, options?: any): AxiosPromise<PlayerInfoResponse> {
      return localVarFp.getPlayer(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Get active bonus for the player
     * @summary Get player active bonuses
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerActivebonuses(id: number, options?: any): AxiosPromise<Array<DBPlayerActiveCasinoBonuses>> {
      return localVarFp.getPlayerActivebonuses(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Get bonus campaigns available for the player
     * @summary Get player eligible bonuses
     * @param {number} id Player internal ID
     * @param {SearchPlayerEligibleBonusesRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerEligibleBonuses(
      id: number,
      payload: SearchPlayerEligibleBonusesRequest,
      options?: any,
    ): AxiosPromise<Array<PlayerEligibleBonus>> {
      return localVarFp.getPlayerEligibleBonuses(id, payload, options).then((request) => request(axios, basePath));
    },
    /**
     * Get player game history
     * @summary Get player game history
     * @param {number} id Player internal ID
     * @param {SearchPlayerGameHistoryRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerGameHistory(
      id: number,
      payload: SearchPlayerGameHistoryRequest,
      options?: any,
    ): AxiosPromise<Array<PlayerGameHistoryRecord>> {
      return localVarFp.getPlayerGameHistory(id, payload, options).then((request) => request(axios, basePath));
    },
    /**
     * Make deposit
     * @summary Make deposit
     * @param {number} id Player internal ID
     * @param {MakeDepositRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeDeposit(id: number, body: MakeDepositRequest, options?: any): AxiosPromise<Deposit> {
      return localVarFp.makeDeposit(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Add game to player favourities list
     * @summary Add game to player favourities list
     * @param {number} id Player internal ID
     * @param {GameFavouritesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePlayerGameFavourites(id: number, body: GameFavouritesRequest, options?: any): AxiosPromise<void> {
      return localVarFp.removePlayerGameFavourites(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Request Phone verification
     * @summary Request Phone verification
     * @param {number} id Player internal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPinVerification(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.requestPinVerification(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Submit KYC application
     * @summary Resolve player KYC application
     * @param {number} id Player internal ID
     * @param {KycResolution} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveKycApplication(id: number, body: KycResolution, options?: any): AxiosPromise<void> {
      return localVarFp.resolveKycApplication(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * StartBonus
     * @param {number} id Player internal ID
     * @param {StartPlayerBonusRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startBonus(id: number, payload: StartPlayerBonusRequest, options?: any): AxiosPromise<void> {
      return localVarFp.startBonus(id, payload, options).then((request) => request(axios, basePath));
    },
    /**
     * Submit KYC applications
     * @summary Submit KYC applications
     * @param {number} id Player internal ID
     * @param {Array<PlayerKycApplication>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitKycApplications(id: number, body: Array<PlayerKycApplication>, options?: any): AxiosPromise<void> {
      return localVarFp.submitKycApplications(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Verify Phone PIN request
     * @summary Verify Phone PIN request
     * @param {number} id Player internal ID
     * @param {VerifyPhoneRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPhoneVerification(id: number, body: VerifyPhoneRequest, options?: any): AxiosPromise<PlayerInfoResponse> {
      return localVarFp.verifyPhoneVerification(id, body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
  /**
   * Acknowledge terms on player behalf
   * @summary Acknowledge casino terms
   * @param {number} id Player internal ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public acknowledgeCasinoTerms(id: number, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .acknowledgeCasinoTerms(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add game to player favourities list
   * @summary Add game to player favourities list
   * @param {number} id Player internal ID
   * @param {GameFavouritesRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public addPlayerGameFavourites(id: number, body: GameFavouritesRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .addPlayerGameFavourites(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * cancelBonus
   * @param {number} id Player internal ID
   * @param {CancelPlayerBonusRequest} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public cancelBonus(id: number, payload: CancelPlayerBonusRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .cancelBonus(id, payload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Change personal information
   * @summary Change personal information
   * @param {number} id Player internal ID
   * @param {ChangePersonalInformationRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public changePersonalInformation(id: number, body: ChangePersonalInformationRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .changePersonalInformation(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Change player consents
   * @summary Change player consents
   * @param {number} id Player internal ID
   * @param {ChangePlayerConsentsRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public changePlayerConsents(id: number, body: ChangePlayerConsentsRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .changePlayerConsents(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Change casino player password
   * @summary Change player password
   * @param {number} id Player internal ID
   * @param {PlayerChangePasswordRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public changePlayerPassword(id: number, body: PlayerChangePasswordRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .changePlayerPassword(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get casino player details
   * @summary Get player info
   * @param {number} id Player internal ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public getPlayer(id: number, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .getPlayer(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get active bonus for the player
   * @summary Get player active bonuses
   * @param {number} id Player internal ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public getPlayerActivebonuses(id: number, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .getPlayerActivebonuses(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get bonus campaigns available for the player
   * @summary Get player eligible bonuses
   * @param {number} id Player internal ID
   * @param {SearchPlayerEligibleBonusesRequest} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public getPlayerEligibleBonuses(
    id: number,
    payload: SearchPlayerEligibleBonusesRequest,
    options?: AxiosRequestConfig,
  ) {
    return PlayersApiFp(this.configuration)
      .getPlayerEligibleBonuses(id, payload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get player game history
   * @summary Get player game history
   * @param {number} id Player internal ID
   * @param {SearchPlayerGameHistoryRequest} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public getPlayerGameHistory(id: number, payload: SearchPlayerGameHistoryRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .getPlayerGameHistory(id, payload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Make deposit
   * @summary Make deposit
   * @param {number} id Player internal ID
   * @param {MakeDepositRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public makeDeposit(id: number, body: MakeDepositRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .makeDeposit(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add game to player favourities list
   * @summary Add game to player favourities list
   * @param {number} id Player internal ID
   * @param {GameFavouritesRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public removePlayerGameFavourites(id: number, body: GameFavouritesRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .removePlayerGameFavourites(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Request Phone verification
   * @summary Request Phone verification
   * @param {number} id Player internal ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public requestPinVerification(id: number, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .requestPinVerification(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Submit KYC application
   * @summary Resolve player KYC application
   * @param {number} id Player internal ID
   * @param {KycResolution} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public resolveKycApplication(id: number, body: KycResolution, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .resolveKycApplication(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * StartBonus
   * @param {number} id Player internal ID
   * @param {StartPlayerBonusRequest} payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public startBonus(id: number, payload: StartPlayerBonusRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .startBonus(id, payload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Submit KYC applications
   * @summary Submit KYC applications
   * @param {number} id Player internal ID
   * @param {Array<PlayerKycApplication>} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public submitKycApplications(id: number, body: Array<PlayerKycApplication>, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .submitKycApplications(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Verify Phone PIN request
   * @summary Verify Phone PIN request
   * @param {number} id Player internal ID
   * @param {VerifyPhoneRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayersApi
   */
  public verifyPhoneVerification(id: number, body: VerifyPhoneRequest, options?: AxiosRequestConfig) {
    return PlayersApiFp(this.configuration)
      .verifyPhoneVerification(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PragmaticplayApi - axios parameter creator
 * @export
 */
export const PragmaticplayApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Casino Operator will change a player balance in appliance with this request and will return an updated balance
     * @summary PragmaticPlay BonusWin
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {number} amount Amount of the win. Minimum is 0.00 (Zero amount is treated as loss)
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} bonusCode Id of the bonus in Casino Operator system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [roundId] Id of the last played round in Free Round Bonus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticBonusWin: async (
      hash: string,
      userId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      bonusCode: string,
      token?: string,
      roundId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('pragmaticBonusWin', 'hash', hash);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('pragmaticBonusWin', 'userId', userId);
      // verify required parameter 'amount' is not null or undefined
      assertParamExists('pragmaticBonusWin', 'amount', amount);
      // verify required parameter 'reference' is not null or undefined
      assertParamExists('pragmaticBonusWin', 'reference', reference);
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('pragmaticBonusWin', 'providerId', providerId);
      // verify required parameter 'timestamp' is not null or undefined
      assertParamExists('pragmaticBonusWin', 'timestamp', timestamp);
      // verify required parameter 'bonusCode' is not null or undefined
      assertParamExists('pragmaticBonusWin', 'bonusCode', bonusCode);
      const localVarPath = `/v1/pragmatic/callback/bonusWin.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (hash !== undefined) {
        localVarFormParams.set('hash', hash as any);
      }

      if (userId !== undefined) {
        localVarFormParams.set('userId', userId as any);
      }

      if (amount !== undefined) {
        localVarFormParams.set('amount', amount as any);
      }

      if (reference !== undefined) {
        localVarFormParams.set('reference', reference as any);
      }

      if (providerId !== undefined) {
        localVarFormParams.set('providerId', providerId as any);
      }

      if (timestamp !== undefined) {
        localVarFormParams.set('timestamp', timestamp as any);
      }

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      if (bonusCode !== undefined) {
        localVarFormParams.set('bonusCode', bonusCode as any);
      }

      if (roundId !== undefined) {
        localVarFormParams.set('roundId', roundId as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Operator should handle the transaction in their system and send the jackpot win transaction id back to the Pragmatic Play.
     * @summary PragmaticPlay JackpotWin
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {number} amount Total amount of all jackpot winnings in the round.
     * @param {string} reference Unique reference of the transaction within the Pragmatic Play system.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the game round.
     * @param {string} jackpotId Id of the jackpot.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticJackpotWin: async (
      hash: string,
      userId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      gameId: string,
      roundId: string,
      jackpotId: string,
      token?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'hash', hash);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'userId', userId);
      // verify required parameter 'amount' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'amount', amount);
      // verify required parameter 'reference' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'reference', reference);
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'providerId', providerId);
      // verify required parameter 'timestamp' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'timestamp', timestamp);
      // verify required parameter 'gameId' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'gameId', gameId);
      // verify required parameter 'roundId' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'roundId', roundId);
      // verify required parameter 'jackpotId' is not null or undefined
      assertParamExists('pragmaticJackpotWin', 'jackpotId', jackpotId);
      const localVarPath = `/v1/pragmatic/callback/jackpotWin.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (hash !== undefined) {
        localVarFormParams.set('hash', hash as any);
      }

      if (userId !== undefined) {
        localVarFormParams.set('userId', userId as any);
      }

      if (amount !== undefined) {
        localVarFormParams.set('amount', amount as any);
      }

      if (reference !== undefined) {
        localVarFormParams.set('reference', reference as any);
      }

      if (providerId !== undefined) {
        localVarFormParams.set('providerId', providerId as any);
      }

      if (timestamp !== undefined) {
        localVarFormParams.set('timestamp', timestamp as any);
      }

      if (gameId !== undefined) {
        localVarFormParams.set('gameId', gameId as any);
      }

      if (roundId !== undefined) {
        localVarFormParams.set('roundId', roundId as any);
      }

      if (jackpotId !== undefined) {
        localVarFormParams.set('jackpotId', jackpotId as any);
      }

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * PragmaticPlay Authenticate
     * @summary PragmaticPlay Authenticate
     * @param {string} hash
     * @param {string} token
     * @param {string} providerId
     * @param {string} [ipAddress]
     * @param {string} [chosenBalance]
     * @param {string} [launchingType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayAuthenticate: async (
      hash: string,
      token: string,
      providerId: string,
      ipAddress?: string,
      chosenBalance?: string,
      launchingType?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('pragmaticPlayAuthenticate', 'hash', hash);
      // verify required parameter 'token' is not null or undefined
      assertParamExists('pragmaticPlayAuthenticate', 'token', token);
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('pragmaticPlayAuthenticate', 'providerId', providerId);
      const localVarPath = `/v1/pragmatic/callback/authenticate.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      if (hash !== undefined) {
        localVarFormParams.append('hash', hash as any);
      }

      if (token !== undefined) {
        localVarFormParams.append('token', token as any);
      }

      if (providerId !== undefined) {
        localVarFormParams.append('providerId', providerId as any);
      }

      if (ipAddress !== undefined) {
        localVarFormParams.append('ipAddress', ipAddress as any);
      }

      if (chosenBalance !== undefined) {
        localVarFormParams.append('chosenBalance', chosenBalance as any);
      }

      if (launchingType !== undefined) {
        localVarFormParams.append('launchingType', launchingType as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets current balance of player and will show it in the game
     * @summary PragmaticPlay Balance
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider identifier.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayBalance: async (
      hash: string,
      providerId: string,
      userId: string,
      token?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('pragmaticPlayBalance', 'hash', hash);
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('pragmaticPlayBalance', 'providerId', providerId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('pragmaticPlayBalance', 'userId', userId);
      const localVarPath = `/v1/pragmatic/callback/balance.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (hash !== undefined) {
        localVarFormParams.set('hash', hash as any);
      }

      if (providerId !== undefined) {
        localVarFormParams.set('providerId', providerId as any);
      }

      if (userId !== undefined) {
        localVarFormParams.set('userId', userId as any);
      }

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Amount of the bet must be subtracted from player balance in Casino Operator system.
     * @summary PragmaticPlay Bet
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the round.
     * @param {number} amount Amount of the bet. Minimum is 0.00.
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider identifier.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} roundDetails Additional information about the current game round.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [bonusCode] Id of the bonus in Casino Operator system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayBet: async (
      hash: string,
      userId: string,
      gameId: string,
      roundId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      roundDetails: string,
      token?: string,
      bonusCode?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'hash', hash);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'userId', userId);
      // verify required parameter 'gameId' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'gameId', gameId);
      // verify required parameter 'roundId' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'roundId', roundId);
      // verify required parameter 'amount' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'amount', amount);
      // verify required parameter 'reference' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'reference', reference);
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'providerId', providerId);
      // verify required parameter 'timestamp' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'timestamp', timestamp);
      // verify required parameter 'roundDetails' is not null or undefined
      assertParamExists('pragmaticPlayBet', 'roundDetails', roundDetails);
      const localVarPath = `/v1/pragmatic/callback/bet.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (hash !== undefined) {
        localVarFormParams.set('hash', hash as any);
      }

      if (userId !== undefined) {
        localVarFormParams.set('userId', userId as any);
      }

      if (gameId !== undefined) {
        localVarFormParams.set('gameId', gameId as any);
      }

      if (roundId !== undefined) {
        localVarFormParams.set('roundId', roundId as any);
      }

      if (amount !== undefined) {
        localVarFormParams.set('amount', amount as any);
      }

      if (reference !== undefined) {
        localVarFormParams.set('reference', reference as any);
      }

      if (providerId !== undefined) {
        localVarFormParams.set('providerId', providerId as any);
      }

      if (timestamp !== undefined) {
        localVarFormParams.set('timestamp', timestamp as any);
      }

      if (roundDetails !== undefined) {
        localVarFormParams.set('roundDetails', roundDetails as any);
      }

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      if (bonusCode !== undefined) {
        localVarFormParams.set('bonusCode', bonusCode as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * PragmaticPlay Demo Game
     * @summary PragmaticPlay Demo Game
     * @param {PragmaticplayDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayDemoGame: async (
      body: PragmaticplayDemoGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('pragmaticPlayDemoGame', 'body', body);
      const localVarPath = `/v1/games/game/demo/pragmaticplay`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Pragmatic Play system may use this method to rollback a bet transaction on the Casino Operator side.
     * @summary PragmaticPlay Refund
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider identifier.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} reference Reference from the original bet transaction.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayRefund: async (
      hash: string,
      providerId: string,
      userId: string,
      reference: string,
      token?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('pragmaticPlayRefund', 'hash', hash);
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('pragmaticPlayRefund', 'providerId', providerId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('pragmaticPlayRefund', 'userId', userId);
      // verify required parameter 'reference' is not null or undefined
      assertParamExists('pragmaticPlayRefund', 'reference', reference);
      const localVarPath = `/v1/pragmatic/callback/refund.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (hash !== undefined) {
        localVarFormParams.set('hash', hash as any);
      }

      if (providerId !== undefined) {
        localVarFormParams.set('providerId', providerId as any);
      }

      if (userId !== undefined) {
        localVarFormParams.set('userId', userId as any);
      }

      if (reference !== undefined) {
        localVarFormParams.set('reference', reference as any);
      }

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The Casino Operator will change the balance of the player in accordance with this request and return the updated balance.
     * @summary PragmaticPlay WIN
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the round.
     * @param {number} amount Amount of the bet. Minimum is 0.00.
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider identifier.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} roundDetails Additional information about the current game round.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [bonusCode] Id of the bonus in Casino Operator system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayResult: async (
      hash: string,
      userId: string,
      gameId: string,
      roundId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      roundDetails: string,
      token?: string,
      bonusCode?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'hash', hash);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'userId', userId);
      // verify required parameter 'gameId' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'gameId', gameId);
      // verify required parameter 'roundId' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'roundId', roundId);
      // verify required parameter 'amount' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'amount', amount);
      // verify required parameter 'reference' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'reference', reference);
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'providerId', providerId);
      // verify required parameter 'timestamp' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'timestamp', timestamp);
      // verify required parameter 'roundDetails' is not null or undefined
      assertParamExists('pragmaticPlayResult', 'roundDetails', roundDetails);
      const localVarPath = `/v1/pragmatic/callback/result.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (hash !== undefined) {
        localVarFormParams.set('hash', hash as any);
      }

      if (userId !== undefined) {
        localVarFormParams.set('userId', userId as any);
      }

      if (gameId !== undefined) {
        localVarFormParams.set('gameId', gameId as any);
      }

      if (roundId !== undefined) {
        localVarFormParams.set('roundId', roundId as any);
      }

      if (amount !== undefined) {
        localVarFormParams.set('amount', amount as any);
      }

      if (reference !== undefined) {
        localVarFormParams.set('reference', reference as any);
      }

      if (providerId !== undefined) {
        localVarFormParams.set('providerId', providerId as any);
      }

      if (timestamp !== undefined) {
        localVarFormParams.set('timestamp', timestamp as any);
      }

      if (roundDetails !== undefined) {
        localVarFormParams.set('roundDetails', roundDetails as any);
      }

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      if (bonusCode !== undefined) {
        localVarFormParams.set('bonusCode', bonusCode as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Operator should handle the transaction in their system and send promo win transaction id back to the Pragmatic Play.
     * @summary PragmaticPlay PromoWin
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} campaignId Id of the campaign.
     * @param {string} campaignType Type of the campaign. Available values are&amp;#58; T  Tournament, CJP  Community Jackpot, C  Chat game winning in bingo, B  Bonus award.
     * @param {number} amount Prize amount that the player is awarded with.
     * @param {string} currency Players currency.
     * @param {string} reference Unique reference of the transaction within the Pragmatic Play system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPromoWin: async (
      hash: string,
      providerId: string,
      timestamp: number,
      userId: string,
      campaignId: string,
      campaignType: string,
      amount: number,
      currency: string,
      reference: string,
      token?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'hash', hash);
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'providerId', providerId);
      // verify required parameter 'timestamp' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'timestamp', timestamp);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'userId', userId);
      // verify required parameter 'campaignId' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'campaignId', campaignId);
      // verify required parameter 'campaignType' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'campaignType', campaignType);
      // verify required parameter 'amount' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'amount', amount);
      // verify required parameter 'currency' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'currency', currency);
      // verify required parameter 'reference' is not null or undefined
      assertParamExists('pragmaticPromoWin', 'reference', reference);
      const localVarPath = `/v1/pragmatic/callback/promoWin.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (hash !== undefined) {
        localVarFormParams.set('hash', hash as any);
      }

      if (providerId !== undefined) {
        localVarFormParams.set('providerId', providerId as any);
      }

      if (timestamp !== undefined) {
        localVarFormParams.set('timestamp', timestamp as any);
      }

      if (userId !== undefined) {
        localVarFormParams.set('userId', userId as any);
      }

      if (campaignId !== undefined) {
        localVarFormParams.set('campaignId', campaignId as any);
      }

      if (campaignType !== undefined) {
        localVarFormParams.set('campaignType', campaignType as any);
      }

      if (amount !== undefined) {
        localVarFormParams.set('amount', amount as any);
      }

      if (currency !== undefined) {
        localVarFormParams.set('currency', currency as any);
      }

      if (reference !== undefined) {
        localVarFormParams.set('reference', reference as any);
      }

      if (token !== undefined) {
        localVarFormParams.set('token', token as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Start PragmaticPlay game
     * @summary Start PragmaticPlay game
     * @param {PragmaticplayStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticplayStartGame: async (
      body: PragmaticplayStartGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('pragmaticplayStartGame', 'body', body);
      const localVarPath = `/v1/games/game/start/pragmaticplay`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PragmaticplayApi - functional programming interface
 * @export
 */
export const PragmaticplayApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PragmaticplayApiAxiosParamCreator(configuration);
  return {
    /**
     * Casino Operator will change a player balance in appliance with this request and will return an updated balance
     * @summary PragmaticPlay BonusWin
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {number} amount Amount of the win. Minimum is 0.00 (Zero amount is treated as loss)
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} bonusCode Id of the bonus in Casino Operator system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [roundId] Id of the last played round in Free Round Bonus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticBonusWin(
      hash: string,
      userId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      bonusCode: string,
      token?: string,
      roundId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticPlayResultResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticBonusWin(
        hash,
        userId,
        amount,
        reference,
        providerId,
        timestamp,
        bonusCode,
        token,
        roundId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Operator should handle the transaction in their system and send the jackpot win transaction id back to the Pragmatic Play.
     * @summary PragmaticPlay JackpotWin
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {number} amount Total amount of all jackpot winnings in the round.
     * @param {string} reference Unique reference of the transaction within the Pragmatic Play system.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the game round.
     * @param {string} jackpotId Id of the jackpot.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticJackpotWin(
      hash: string,
      userId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      gameId: string,
      roundId: string,
      jackpotId: string,
      token?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticPlayResultResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticJackpotWin(
        hash,
        userId,
        amount,
        reference,
        providerId,
        timestamp,
        gameId,
        roundId,
        jackpotId,
        token,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * PragmaticPlay Authenticate
     * @summary PragmaticPlay Authenticate
     * @param {string} hash
     * @param {string} token
     * @param {string} providerId
     * @param {string} [ipAddress]
     * @param {string} [chosenBalance]
     * @param {string} [launchingType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticPlayAuthenticate(
      hash: string,
      token: string,
      providerId: string,
      ipAddress?: string,
      chosenBalance?: string,
      launchingType?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticPlayAuthenticateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticPlayAuthenticate(
        hash,
        token,
        providerId,
        ipAddress,
        chosenBalance,
        launchingType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Gets current balance of player and will show it in the game
     * @summary PragmaticPlay Balance
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider identifier.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticPlayBalance(
      hash: string,
      providerId: string,
      userId: string,
      token?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticPlayBalanceResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticPlayBalance(
        hash,
        providerId,
        userId,
        token,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Amount of the bet must be subtracted from player balance in Casino Operator system.
     * @summary PragmaticPlay Bet
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the round.
     * @param {number} amount Amount of the bet. Minimum is 0.00.
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider identifier.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} roundDetails Additional information about the current game round.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [bonusCode] Id of the bonus in Casino Operator system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticPlayBet(
      hash: string,
      userId: string,
      gameId: string,
      roundId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      roundDetails: string,
      token?: string,
      bonusCode?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticPlayBetResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticPlayBet(
        hash,
        userId,
        gameId,
        roundId,
        amount,
        reference,
        providerId,
        timestamp,
        roundDetails,
        token,
        bonusCode,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * PragmaticPlay Demo Game
     * @summary PragmaticPlay Demo Game
     * @param {PragmaticplayDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticPlayDemoGame(
      body: PragmaticplayDemoGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticplayDemoGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticPlayDemoGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Pragmatic Play system may use this method to rollback a bet transaction on the Casino Operator side.
     * @summary PragmaticPlay Refund
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider identifier.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} reference Reference from the original bet transaction.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticPlayRefund(
      hash: string,
      providerId: string,
      userId: string,
      reference: string,
      token?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticPlayRefundResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticPlayRefund(
        hash,
        providerId,
        userId,
        reference,
        token,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * The Casino Operator will change the balance of the player in accordance with this request and return the updated balance.
     * @summary PragmaticPlay WIN
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the round.
     * @param {number} amount Amount of the bet. Minimum is 0.00.
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider identifier.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} roundDetails Additional information about the current game round.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [bonusCode] Id of the bonus in Casino Operator system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticPlayResult(
      hash: string,
      userId: string,
      gameId: string,
      roundId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      roundDetails: string,
      token?: string,
      bonusCode?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticPlayResultResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticPlayResult(
        hash,
        userId,
        gameId,
        roundId,
        amount,
        reference,
        providerId,
        timestamp,
        roundDetails,
        token,
        bonusCode,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Operator should handle the transaction in their system and send promo win transaction id back to the Pragmatic Play.
     * @summary PragmaticPlay PromoWin
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} campaignId Id of the campaign.
     * @param {string} campaignType Type of the campaign. Available values are&amp;#58; T  Tournament, CJP  Community Jackpot, C  Chat game winning in bingo, B  Bonus award.
     * @param {number} amount Prize amount that the player is awarded with.
     * @param {string} currency Players currency.
     * @param {string} reference Unique reference of the transaction within the Pragmatic Play system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticPromoWin(
      hash: string,
      providerId: string,
      timestamp: number,
      userId: string,
      campaignId: string,
      campaignType: string,
      amount: number,
      currency: string,
      reference: string,
      token?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticPlayResultResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticPromoWin(
        hash,
        providerId,
        timestamp,
        userId,
        campaignId,
        campaignType,
        amount,
        currency,
        reference,
        token,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Start PragmaticPlay game
     * @summary Start PragmaticPlay game
     * @param {PragmaticplayStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pragmaticplayStartGame(
      body: PragmaticplayStartGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PragmaticplayStartGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pragmaticplayStartGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PragmaticplayApi - factory interface
 * @export
 */
export const PragmaticplayApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PragmaticplayApiFp(configuration);
  return {
    /**
     * Casino Operator will change a player balance in appliance with this request and will return an updated balance
     * @summary PragmaticPlay BonusWin
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {number} amount Amount of the win. Minimum is 0.00 (Zero amount is treated as loss)
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} bonusCode Id of the bonus in Casino Operator system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [roundId] Id of the last played round in Free Round Bonus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticBonusWin(
      hash: string,
      userId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      bonusCode: string,
      token?: string,
      roundId?: string,
      options?: any,
    ): AxiosPromise<PragmaticPlayResultResponse> {
      return localVarFp
        .pragmaticBonusWin(hash, userId, amount, reference, providerId, timestamp, bonusCode, token, roundId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Operator should handle the transaction in their system and send the jackpot win transaction id back to the Pragmatic Play.
     * @summary PragmaticPlay JackpotWin
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {number} amount Total amount of all jackpot winnings in the round.
     * @param {string} reference Unique reference of the transaction within the Pragmatic Play system.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the game round.
     * @param {string} jackpotId Id of the jackpot.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticJackpotWin(
      hash: string,
      userId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      gameId: string,
      roundId: string,
      jackpotId: string,
      token?: string,
      options?: any,
    ): AxiosPromise<PragmaticPlayResultResponse> {
      return localVarFp
        .pragmaticJackpotWin(
          hash,
          userId,
          amount,
          reference,
          providerId,
          timestamp,
          gameId,
          roundId,
          jackpotId,
          token,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * PragmaticPlay Authenticate
     * @summary PragmaticPlay Authenticate
     * @param {string} hash
     * @param {string} token
     * @param {string} providerId
     * @param {string} [ipAddress]
     * @param {string} [chosenBalance]
     * @param {string} [launchingType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayAuthenticate(
      hash: string,
      token: string,
      providerId: string,
      ipAddress?: string,
      chosenBalance?: string,
      launchingType?: string,
      options?: any,
    ): AxiosPromise<PragmaticPlayAuthenticateResponse> {
      return localVarFp
        .pragmaticPlayAuthenticate(hash, token, providerId, ipAddress, chosenBalance, launchingType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets current balance of player and will show it in the game
     * @summary PragmaticPlay Balance
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider identifier.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayBalance(
      hash: string,
      providerId: string,
      userId: string,
      token?: string,
      options?: any,
    ): AxiosPromise<PragmaticPlayBalanceResponse> {
      return localVarFp
        .pragmaticPlayBalance(hash, providerId, userId, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Amount of the bet must be subtracted from player balance in Casino Operator system.
     * @summary PragmaticPlay Bet
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the round.
     * @param {number} amount Amount of the bet. Minimum is 0.00.
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider identifier.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} roundDetails Additional information about the current game round.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [bonusCode] Id of the bonus in Casino Operator system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayBet(
      hash: string,
      userId: string,
      gameId: string,
      roundId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      roundDetails: string,
      token?: string,
      bonusCode?: string,
      options?: any,
    ): AxiosPromise<PragmaticPlayBetResponse> {
      return localVarFp
        .pragmaticPlayBet(
          hash,
          userId,
          gameId,
          roundId,
          amount,
          reference,
          providerId,
          timestamp,
          roundDetails,
          token,
          bonusCode,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * PragmaticPlay Demo Game
     * @summary PragmaticPlay Demo Game
     * @param {PragmaticplayDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayDemoGame(
      body: PragmaticplayDemoGameRequest,
      options?: any,
    ): AxiosPromise<PragmaticplayDemoGameResponse> {
      return localVarFp.pragmaticPlayDemoGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Pragmatic Play system may use this method to rollback a bet transaction on the Casino Operator side.
     * @summary PragmaticPlay Refund
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider identifier.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} reference Reference from the original bet transaction.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayRefund(
      hash: string,
      providerId: string,
      userId: string,
      reference: string,
      token?: string,
      options?: any,
    ): AxiosPromise<PragmaticPlayRefundResponse> {
      return localVarFp
        .pragmaticPlayRefund(hash, providerId, userId, reference, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The Casino Operator will change the balance of the player in accordance with this request and return the updated balance.
     * @summary PragmaticPlay WIN
     * @param {string} hash Hash code of the request.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} gameId Id of the game.
     * @param {string} roundId Id of the round.
     * @param {number} amount Amount of the bet. Minimum is 0.00.
     * @param {string} reference Unique reference of this transaction.
     * @param {string} providerId Game Provider identifier.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
     * @param {string} roundDetails Additional information about the current game round.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {string} [bonusCode] Id of the bonus in Casino Operator system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPlayResult(
      hash: string,
      userId: string,
      gameId: string,
      roundId: string,
      amount: number,
      reference: string,
      providerId: string,
      timestamp: number,
      roundDetails: string,
      token?: string,
      bonusCode?: string,
      options?: any,
    ): AxiosPromise<PragmaticPlayResultResponse> {
      return localVarFp
        .pragmaticPlayResult(
          hash,
          userId,
          gameId,
          roundId,
          amount,
          reference,
          providerId,
          timestamp,
          roundDetails,
          token,
          bonusCode,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Operator should handle the transaction in their system and send promo win transaction id back to the Pragmatic Play.
     * @summary PragmaticPlay PromoWin
     * @param {string} hash Hash code of the request.
     * @param {string} providerId Game Provider id.
     * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side.
     * @param {string} userId Identifier of the user within the Casino Operators system.
     * @param {string} campaignId Id of the campaign.
     * @param {string} campaignType Type of the campaign. Available values are&amp;#58; T  Tournament, CJP  Community Jackpot, C  Chat game winning in bingo, B  Bonus award.
     * @param {number} amount Prize amount that the player is awarded with.
     * @param {string} currency Players currency.
     * @param {string} reference Unique reference of the transaction within the Pragmatic Play system.
     * @param {string} [token] Token of the player from Authenticate response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticPromoWin(
      hash: string,
      providerId: string,
      timestamp: number,
      userId: string,
      campaignId: string,
      campaignType: string,
      amount: number,
      currency: string,
      reference: string,
      token?: string,
      options?: any,
    ): AxiosPromise<PragmaticPlayResultResponse> {
      return localVarFp
        .pragmaticPromoWin(
          hash,
          providerId,
          timestamp,
          userId,
          campaignId,
          campaignType,
          amount,
          currency,
          reference,
          token,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Start PragmaticPlay game
     * @summary Start PragmaticPlay game
     * @param {PragmaticplayStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pragmaticplayStartGame(
      body: PragmaticplayStartGameRequest,
      options?: any,
    ): AxiosPromise<PragmaticplayStartGameResponse> {
      return localVarFp.pragmaticplayStartGame(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * PragmaticplayApi - object-oriented interface
 * @export
 * @class PragmaticplayApi
 * @extends {BaseAPI}
 */
export class PragmaticplayApi extends BaseAPI {
  /**
   * Casino Operator will change a player balance in appliance with this request and will return an updated balance
   * @summary PragmaticPlay BonusWin
   * @param {string} hash Hash code of the request.
   * @param {string} userId Identifier of the user within the Casino Operators system.
   * @param {number} amount Amount of the win. Minimum is 0.00 (Zero amount is treated as loss)
   * @param {string} reference Unique reference of this transaction.
   * @param {string} providerId Game Provider id.
   * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
   * @param {string} bonusCode Id of the bonus in Casino Operator system.
   * @param {string} [token] Token of the player from Authenticate response.
   * @param {string} [roundId] Id of the last played round in Free Round Bonus
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticBonusWin(
    hash: string,
    userId: string,
    amount: number,
    reference: string,
    providerId: string,
    timestamp: number,
    bonusCode: string,
    token?: string,
    roundId?: string,
    options?: AxiosRequestConfig,
  ) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticBonusWin(hash, userId, amount, reference, providerId, timestamp, bonusCode, token, roundId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Operator should handle the transaction in their system and send the jackpot win transaction id back to the Pragmatic Play.
   * @summary PragmaticPlay JackpotWin
   * @param {string} hash Hash code of the request.
   * @param {string} userId Identifier of the user within the Casino Operators system.
   * @param {number} amount Total amount of all jackpot winnings in the round.
   * @param {string} reference Unique reference of the transaction within the Pragmatic Play system.
   * @param {string} providerId Game Provider id.
   * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side.
   * @param {string} gameId Id of the game.
   * @param {string} roundId Id of the game round.
   * @param {string} jackpotId Id of the jackpot.
   * @param {string} [token] Token of the player from Authenticate response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticJackpotWin(
    hash: string,
    userId: string,
    amount: number,
    reference: string,
    providerId: string,
    timestamp: number,
    gameId: string,
    roundId: string,
    jackpotId: string,
    token?: string,
    options?: AxiosRequestConfig,
  ) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticJackpotWin(
        hash,
        userId,
        amount,
        reference,
        providerId,
        timestamp,
        gameId,
        roundId,
        jackpotId,
        token,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * PragmaticPlay Authenticate
   * @summary PragmaticPlay Authenticate
   * @param {string} hash
   * @param {string} token
   * @param {string} providerId
   * @param {string} [ipAddress]
   * @param {string} [chosenBalance]
   * @param {string} [launchingType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticPlayAuthenticate(
    hash: string,
    token: string,
    providerId: string,
    ipAddress?: string,
    chosenBalance?: string,
    launchingType?: string,
    options?: AxiosRequestConfig,
  ) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticPlayAuthenticate(hash, token, providerId, ipAddress, chosenBalance, launchingType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets current balance of player and will show it in the game
   * @summary PragmaticPlay Balance
   * @param {string} hash Hash code of the request.
   * @param {string} providerId Game Provider identifier.
   * @param {string} userId Identifier of the user within the Casino Operators system.
   * @param {string} [token] Token of the player from Authenticate response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticPlayBalance(
    hash: string,
    providerId: string,
    userId: string,
    token?: string,
    options?: AxiosRequestConfig,
  ) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticPlayBalance(hash, providerId, userId, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Amount of the bet must be subtracted from player balance in Casino Operator system.
   * @summary PragmaticPlay Bet
   * @param {string} hash Hash code of the request.
   * @param {string} userId Identifier of the user within the Casino Operators system.
   * @param {string} gameId Id of the game.
   * @param {string} roundId Id of the round.
   * @param {number} amount Amount of the bet. Minimum is 0.00.
   * @param {string} reference Unique reference of this transaction.
   * @param {string} providerId Game Provider identifier.
   * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
   * @param {string} roundDetails Additional information about the current game round.
   * @param {string} [token] Token of the player from Authenticate response.
   * @param {string} [bonusCode] Id of the bonus in Casino Operator system
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticPlayBet(
    hash: string,
    userId: string,
    gameId: string,
    roundId: string,
    amount: number,
    reference: string,
    providerId: string,
    timestamp: number,
    roundDetails: string,
    token?: string,
    bonusCode?: string,
    options?: AxiosRequestConfig,
  ) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticPlayBet(
        hash,
        userId,
        gameId,
        roundId,
        amount,
        reference,
        providerId,
        timestamp,
        roundDetails,
        token,
        bonusCode,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * PragmaticPlay Demo Game
   * @summary PragmaticPlay Demo Game
   * @param {PragmaticplayDemoGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticPlayDemoGame(body: PragmaticplayDemoGameRequest, options?: AxiosRequestConfig) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticPlayDemoGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Pragmatic Play system may use this method to rollback a bet transaction on the Casino Operator side.
   * @summary PragmaticPlay Refund
   * @param {string} hash Hash code of the request.
   * @param {string} providerId Game Provider identifier.
   * @param {string} userId Identifier of the user within the Casino Operators system.
   * @param {string} reference Reference from the original bet transaction.
   * @param {string} [token] Token of the player from Authenticate response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticPlayRefund(
    hash: string,
    providerId: string,
    userId: string,
    reference: string,
    token?: string,
    options?: AxiosRequestConfig,
  ) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticPlayRefund(hash, providerId, userId, reference, token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The Casino Operator will change the balance of the player in accordance with this request and return the updated balance.
   * @summary PragmaticPlay WIN
   * @param {string} hash Hash code of the request.
   * @param {string} userId Identifier of the user within the Casino Operators system.
   * @param {string} gameId Id of the game.
   * @param {string} roundId Id of the round.
   * @param {number} amount Amount of the bet. Minimum is 0.00.
   * @param {string} reference Unique reference of this transaction.
   * @param {string} providerId Game Provider identifier.
   * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side
   * @param {string} roundDetails Additional information about the current game round.
   * @param {string} [token] Token of the player from Authenticate response.
   * @param {string} [bonusCode] Id of the bonus in Casino Operator system
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticPlayResult(
    hash: string,
    userId: string,
    gameId: string,
    roundId: string,
    amount: number,
    reference: string,
    providerId: string,
    timestamp: number,
    roundDetails: string,
    token?: string,
    bonusCode?: string,
    options?: AxiosRequestConfig,
  ) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticPlayResult(
        hash,
        userId,
        gameId,
        roundId,
        amount,
        reference,
        providerId,
        timestamp,
        roundDetails,
        token,
        bonusCode,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Operator should handle the transaction in their system and send promo win transaction id back to the Pragmatic Play.
   * @summary PragmaticPlay PromoWin
   * @param {string} hash Hash code of the request.
   * @param {string} providerId Game Provider id.
   * @param {number} timestamp Date and time when the transaction is processed on the Pragmatic Play side.
   * @param {string} userId Identifier of the user within the Casino Operators system.
   * @param {string} campaignId Id of the campaign.
   * @param {string} campaignType Type of the campaign. Available values are&amp;#58; T  Tournament, CJP  Community Jackpot, C  Chat game winning in bingo, B  Bonus award.
   * @param {number} amount Prize amount that the player is awarded with.
   * @param {string} currency Players currency.
   * @param {string} reference Unique reference of the transaction within the Pragmatic Play system.
   * @param {string} [token] Token of the player from Authenticate response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticPromoWin(
    hash: string,
    providerId: string,
    timestamp: number,
    userId: string,
    campaignId: string,
    campaignType: string,
    amount: number,
    currency: string,
    reference: string,
    token?: string,
    options?: AxiosRequestConfig,
  ) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticPromoWin(
        hash,
        providerId,
        timestamp,
        userId,
        campaignId,
        campaignType,
        amount,
        currency,
        reference,
        token,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Start PragmaticPlay game
   * @summary Start PragmaticPlay game
   * @param {PragmaticplayStartGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PragmaticplayApi
   */
  public pragmaticplayStartGame(body: PragmaticplayStartGameRequest, options?: AxiosRequestConfig) {
    return PragmaticplayApiFp(this.configuration)
      .pragmaticplayStartGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SitesessionsApi - axios parameter creator
 * @export
 */
export const SitesessionsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Inalidate casino player site session
     * @summary Invalidate player site session
     * @param {ValidateSiteSessionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invalidateSiteSession: async (
      body: ValidateSiteSessionRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('invalidateSiteSession', 'body', body);
      const localVarPath = `/v1/site-sessions/invalidate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validate casino player site session
     * @summary Validate player site session
     * @param {ValidateSiteSessionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateSiteSession: async (
      body: ValidateSiteSessionRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('validateSiteSession', 'body', body);
      const localVarPath = `/v1/site-sessions/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SitesessionsApi - functional programming interface
 * @export
 */
export const SitesessionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SitesessionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Inalidate casino player site session
     * @summary Invalidate player site session
     * @param {ValidateSiteSessionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invalidateSiteSession(
      body: ValidateSiteSessionRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.invalidateSiteSession(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Validate casino player site session
     * @summary Validate player site session
     * @param {ValidateSiteSessionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateSiteSession(
      body: ValidateSiteSessionRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateSiteSessionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateSiteSession(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SitesessionsApi - factory interface
 * @export
 */
export const SitesessionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SitesessionsApiFp(configuration);
  return {
    /**
     * Inalidate casino player site session
     * @summary Invalidate player site session
     * @param {ValidateSiteSessionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invalidateSiteSession(body: ValidateSiteSessionRequest, options?: any): AxiosPromise<void> {
      return localVarFp.invalidateSiteSession(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Validate casino player site session
     * @summary Validate player site session
     * @param {ValidateSiteSessionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateSiteSession(body: ValidateSiteSessionRequest, options?: any): AxiosPromise<ValidateSiteSessionResponse> {
      return localVarFp.validateSiteSession(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * SitesessionsApi - object-oriented interface
 * @export
 * @class SitesessionsApi
 * @extends {BaseAPI}
 */
export class SitesessionsApi extends BaseAPI {
  /**
   * Inalidate casino player site session
   * @summary Invalidate player site session
   * @param {ValidateSiteSessionRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitesessionsApi
   */
  public invalidateSiteSession(body: ValidateSiteSessionRequest, options?: AxiosRequestConfig) {
    return SitesessionsApiFp(this.configuration)
      .invalidateSiteSession(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Validate casino player site session
   * @summary Validate player site session
   * @param {ValidateSiteSessionRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SitesessionsApi
   */
  public validateSiteSession(body: ValidateSiteSessionRequest, options?: AxiosRequestConfig) {
    return SitesessionsApiFp(this.configuration)
      .validateSiteSession(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SlotegratorApi - axios parameter creator
 * @export
 */
export const SlotegratorApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Slotegrator Action
     * @summary Slotegrator Action
     * @param {string} action
     * @param {string} playerId
     * @param {string} [xMerchantId]
     * @param {string} [xTimestamp]
     * @param {string} [xNonce]
     * @param {string} [xSign]
     * @param {string} [transactionId]
     * @param {string} [type]
     * @param {string} [betTransactionId]
     * @param {string} [sessionId]
     * @param {string} [amount]
     * @param {string} [currency]
     * @param {string} [gameUuid]
     * @param {string} [freespinId]
     * @param {number} [quantity]
     * @param {string} [roundId]
     * @param {boolean} [finished]
     * @param {string} [rollbackTransactions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorAction: async (
      action: string,
      playerId: string,
      xMerchantId?: string,
      xTimestamp?: string,
      xNonce?: string,
      xSign?: string,
      transactionId?: string,
      type?: string,
      betTransactionId?: string,
      sessionId?: string,
      amount?: string,
      currency?: string,
      gameUuid?: string,
      freespinId?: string,
      quantity?: number,
      roundId?: string,
      finished?: boolean,
      rollbackTransactions?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'action' is not null or undefined
      assertParamExists('slotegratorAction', 'action', action);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('slotegratorAction', 'playerId', playerId);
      const localVarPath = `/v1/slotegrator/callback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      if (xMerchantId !== undefined && xMerchantId !== null) {
        localVarHeaderParameter['X-Merchant-Id'] = String(xMerchantId);
      }

      if (xTimestamp !== undefined && xTimestamp !== null) {
        localVarHeaderParameter['X-Timestamp'] = String(xTimestamp);
      }

      if (xNonce !== undefined && xNonce !== null) {
        localVarHeaderParameter['X-Nonce'] = String(xNonce);
      }

      if (xSign !== undefined && xSign !== null) {
        localVarHeaderParameter['X-Sign'] = String(xSign);
      }

      if (transactionId !== undefined) {
        localVarFormParams.append('transaction_id', transactionId as any);
      }

      if (type !== undefined) {
        localVarFormParams.append('type', type as any);
      }

      if (action !== undefined) {
        localVarFormParams.append('action', action as any);
      }

      if (playerId !== undefined) {
        localVarFormParams.append('player_id', playerId as any);
      }

      if (betTransactionId !== undefined) {
        localVarFormParams.append('bet_transaction_id', betTransactionId as any);
      }

      if (sessionId !== undefined) {
        localVarFormParams.append('session_id', sessionId as any);
      }

      if (amount !== undefined) {
        localVarFormParams.append('amount', amount as any);
      }

      if (currency !== undefined) {
        localVarFormParams.append('currency', currency as any);
      }

      if (gameUuid !== undefined) {
        localVarFormParams.append('game_uuid', gameUuid as any);
      }

      if (freespinId !== undefined) {
        localVarFormParams.append('freespin_id', freespinId as any);
      }

      if (quantity !== undefined) {
        localVarFormParams.append('quantity', quantity as any);
      }

      if (roundId !== undefined) {
        localVarFormParams.append('round_id', roundId as any);
      }

      if (finished !== undefined) {
        localVarFormParams.append('finished', finished as any);
      }

      if (rollbackTransactions !== undefined) {
        localVarFormParams.append('rollback_transactions', rollbackTransactions as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Slotegrator Demo Game
     * @summary Slotegrator Demo Game
     * @param {SlotegratorDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorDemoGame: async (
      body: SlotegratorDemoGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('slotegratorDemoGame', 'body', body);
      const localVarPath = `/v1/games/game/demo/slotegrator`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Slotegrator Self Validate
     * @summary Slotegrator Self Validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorSelfValidate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/slotegrator/self-validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Start Slotegrator game
     * @summary Start Slotegrator game
     * @param {SlotegratorStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorStartGame: async (
      body: SlotegratorStartGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('slotegratorStartGame', 'body', body);
      const localVarPath = `/v1/games/game/start/slotegrator`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SlotegratorApi - functional programming interface
 * @export
 */
export const SlotegratorApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SlotegratorApiAxiosParamCreator(configuration);
  return {
    /**
     * Slotegrator Action
     * @summary Slotegrator Action
     * @param {string} action
     * @param {string} playerId
     * @param {string} [xMerchantId]
     * @param {string} [xTimestamp]
     * @param {string} [xNonce]
     * @param {string} [xSign]
     * @param {string} [transactionId]
     * @param {string} [type]
     * @param {string} [betTransactionId]
     * @param {string} [sessionId]
     * @param {string} [amount]
     * @param {string} [currency]
     * @param {string} [gameUuid]
     * @param {string} [freespinId]
     * @param {number} [quantity]
     * @param {string} [roundId]
     * @param {boolean} [finished]
     * @param {string} [rollbackTransactions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slotegratorAction(
      action: string,
      playerId: string,
      xMerchantId?: string,
      xTimestamp?: string,
      xNonce?: string,
      xSign?: string,
      transactionId?: string,
      type?: string,
      betTransactionId?: string,
      sessionId?: string,
      amount?: string,
      currency?: string,
      gameUuid?: string,
      freespinId?: string,
      quantity?: number,
      roundId?: string,
      finished?: boolean,
      rollbackTransactions?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlotegratorActionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slotegratorAction(
        action,
        playerId,
        xMerchantId,
        xTimestamp,
        xNonce,
        xSign,
        transactionId,
        type,
        betTransactionId,
        sessionId,
        amount,
        currency,
        gameUuid,
        freespinId,
        quantity,
        roundId,
        finished,
        rollbackTransactions,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Slotegrator Demo Game
     * @summary Slotegrator Demo Game
     * @param {SlotegratorDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slotegratorDemoGame(
      body: SlotegratorDemoGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlotegratorDemoGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slotegratorDemoGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Slotegrator Self Validate
     * @summary Slotegrator Self Validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slotegratorSelfValidate(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slotegratorSelfValidate(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Start Slotegrator game
     * @summary Start Slotegrator game
     * @param {SlotegratorStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slotegratorStartGame(
      body: SlotegratorStartGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlotegratorStartGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slotegratorStartGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SlotegratorApi - factory interface
 * @export
 */
export const SlotegratorApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SlotegratorApiFp(configuration);
  return {
    /**
     * Slotegrator Action
     * @summary Slotegrator Action
     * @param {string} action
     * @param {string} playerId
     * @param {string} [xMerchantId]
     * @param {string} [xTimestamp]
     * @param {string} [xNonce]
     * @param {string} [xSign]
     * @param {string} [transactionId]
     * @param {string} [type]
     * @param {string} [betTransactionId]
     * @param {string} [sessionId]
     * @param {string} [amount]
     * @param {string} [currency]
     * @param {string} [gameUuid]
     * @param {string} [freespinId]
     * @param {number} [quantity]
     * @param {string} [roundId]
     * @param {boolean} [finished]
     * @param {string} [rollbackTransactions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorAction(
      action: string,
      playerId: string,
      xMerchantId?: string,
      xTimestamp?: string,
      xNonce?: string,
      xSign?: string,
      transactionId?: string,
      type?: string,
      betTransactionId?: string,
      sessionId?: string,
      amount?: string,
      currency?: string,
      gameUuid?: string,
      freespinId?: string,
      quantity?: number,
      roundId?: string,
      finished?: boolean,
      rollbackTransactions?: string,
      options?: any,
    ): AxiosPromise<SlotegratorActionResponse> {
      return localVarFp
        .slotegratorAction(
          action,
          playerId,
          xMerchantId,
          xTimestamp,
          xNonce,
          xSign,
          transactionId,
          type,
          betTransactionId,
          sessionId,
          amount,
          currency,
          gameUuid,
          freespinId,
          quantity,
          roundId,
          finished,
          rollbackTransactions,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Slotegrator Demo Game
     * @summary Slotegrator Demo Game
     * @param {SlotegratorDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorDemoGame(body: SlotegratorDemoGameRequest, options?: any): AxiosPromise<SlotegratorDemoGameResponse> {
      return localVarFp.slotegratorDemoGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Slotegrator Self Validate
     * @summary Slotegrator Self Validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorSelfValidate(options?: any): AxiosPromise<object> {
      return localVarFp.slotegratorSelfValidate(options).then((request) => request(axios, basePath));
    },
    /**
     * Start Slotegrator game
     * @summary Start Slotegrator game
     * @param {SlotegratorStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slotegratorStartGame(body: SlotegratorStartGameRequest, options?: any): AxiosPromise<SlotegratorStartGameResponse> {
      return localVarFp.slotegratorStartGame(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * SlotegratorApi - object-oriented interface
 * @export
 * @class SlotegratorApi
 * @extends {BaseAPI}
 */
export class SlotegratorApi extends BaseAPI {
  /**
   * Slotegrator Action
   * @summary Slotegrator Action
   * @param {string} action
   * @param {string} playerId
   * @param {string} [xMerchantId]
   * @param {string} [xTimestamp]
   * @param {string} [xNonce]
   * @param {string} [xSign]
   * @param {string} [transactionId]
   * @param {string} [type]
   * @param {string} [betTransactionId]
   * @param {string} [sessionId]
   * @param {string} [amount]
   * @param {string} [currency]
   * @param {string} [gameUuid]
   * @param {string} [freespinId]
   * @param {number} [quantity]
   * @param {string} [roundId]
   * @param {boolean} [finished]
   * @param {string} [rollbackTransactions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlotegratorApi
   */
  public slotegratorAction(
    action: string,
    playerId: string,
    xMerchantId?: string,
    xTimestamp?: string,
    xNonce?: string,
    xSign?: string,
    transactionId?: string,
    type?: string,
    betTransactionId?: string,
    sessionId?: string,
    amount?: string,
    currency?: string,
    gameUuid?: string,
    freespinId?: string,
    quantity?: number,
    roundId?: string,
    finished?: boolean,
    rollbackTransactions?: string,
    options?: AxiosRequestConfig,
  ) {
    return SlotegratorApiFp(this.configuration)
      .slotegratorAction(
        action,
        playerId,
        xMerchantId,
        xTimestamp,
        xNonce,
        xSign,
        transactionId,
        type,
        betTransactionId,
        sessionId,
        amount,
        currency,
        gameUuid,
        freespinId,
        quantity,
        roundId,
        finished,
        rollbackTransactions,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Slotegrator Demo Game
   * @summary Slotegrator Demo Game
   * @param {SlotegratorDemoGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlotegratorApi
   */
  public slotegratorDemoGame(body: SlotegratorDemoGameRequest, options?: AxiosRequestConfig) {
    return SlotegratorApiFp(this.configuration)
      .slotegratorDemoGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Slotegrator Self Validate
   * @summary Slotegrator Self Validate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlotegratorApi
   */
  public slotegratorSelfValidate(options?: AxiosRequestConfig) {
    return SlotegratorApiFp(this.configuration)
      .slotegratorSelfValidate(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Start Slotegrator game
   * @summary Start Slotegrator game
   * @param {SlotegratorStartGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlotegratorApi
   */
  public slotegratorStartGame(body: SlotegratorStartGameRequest, options?: AxiosRequestConfig) {
    return SlotegratorApiFp(this.configuration)
      .slotegratorStartGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SoftswissApi - axios parameter creator
 * @export
 */
export const SoftswissApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * SoftSwiss Play
     * @summary SoftSwiss Play
     * @param {SoftSwissPlayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softSwissPlay: async (body: SoftSwissPlayRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('softSwissPlay', 'body', body);
      const localVarPath = `/v1/softswiss/callback/play`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * SoftSwiss Rollback
     * @summary SoftSwiss Rollback
     * @param {SoftSwissRollbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softSwissRollback: async (
      body: SoftSwissRollbackRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('softSwissRollback', 'body', body);
      const localVarPath = `/v1/softswiss/callback/rollback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Softswiss Demo Game
     * @summary Softswiss Demo Game
     * @param {SoftSwissDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softswissDemoGame: async (
      body: SoftSwissDemoGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('softswissDemoGame', 'body', body);
      const localVarPath = `/v1/games/game/demo/softswiss`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Start Softswiss game
     * @summary Start Softswiss game
     * @param {SoftSwissStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softswissStartGame: async (
      body: SoftSwissStartGameRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('softswissStartGame', 'body', body);
      const localVarPath = `/v1/games/game/start/softswiss`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Uploads games file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1SoftswissGamesUploadPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/softswiss/games/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SoftswissApi - functional programming interface
 * @export
 */
export const SoftswissApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SoftswissApiAxiosParamCreator(configuration);
  return {
    /**
     * SoftSwiss Play
     * @summary SoftSwiss Play
     * @param {SoftSwissPlayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async softSwissPlay(
      body: SoftSwissPlayRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftSwissPlayResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.softSwissPlay(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * SoftSwiss Rollback
     * @summary SoftSwiss Rollback
     * @param {SoftSwissRollbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async softSwissRollback(
      body: SoftSwissRollbackRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftSwissRollbackResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.softSwissRollback(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Softswiss Demo Game
     * @summary Softswiss Demo Game
     * @param {SoftSwissDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async softswissDemoGame(
      body: SoftSwissDemoGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftSwissDemoGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.softswissDemoGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Start Softswiss game
     * @summary Start Softswiss game
     * @param {SoftSwissStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async softswissStartGame(
      body: SoftSwissStartGameRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftSwissStartGameResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.softswissStartGame(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Uploads games file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1SoftswissGamesUploadPost(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1SoftswissGamesUploadPost(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SoftswissApi - factory interface
 * @export
 */
export const SoftswissApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SoftswissApiFp(configuration);
  return {
    /**
     * SoftSwiss Play
     * @summary SoftSwiss Play
     * @param {SoftSwissPlayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softSwissPlay(body: SoftSwissPlayRequest, options?: any): AxiosPromise<SoftSwissPlayResponse> {
      return localVarFp.softSwissPlay(body, options).then((request) => request(axios, basePath));
    },
    /**
     * SoftSwiss Rollback
     * @summary SoftSwiss Rollback
     * @param {SoftSwissRollbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softSwissRollback(body: SoftSwissRollbackRequest, options?: any): AxiosPromise<SoftSwissRollbackResponse> {
      return localVarFp.softSwissRollback(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Softswiss Demo Game
     * @summary Softswiss Demo Game
     * @param {SoftSwissDemoGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softswissDemoGame(body: SoftSwissDemoGameRequest, options?: any): AxiosPromise<SoftSwissDemoGameResponse> {
      return localVarFp.softswissDemoGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Start Softswiss game
     * @summary Start Softswiss game
     * @param {SoftSwissStartGameRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softswissStartGame(body: SoftSwissStartGameRequest, options?: any): AxiosPromise<SoftSwissStartGameResponse> {
      return localVarFp.softswissStartGame(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Uploads games file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1SoftswissGamesUploadPost(options?: any): AxiosPromise<object> {
      return localVarFp.v1SoftswissGamesUploadPost(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * SoftswissApi - object-oriented interface
 * @export
 * @class SoftswissApi
 * @extends {BaseAPI}
 */
export class SoftswissApi extends BaseAPI {
  /**
   * SoftSwiss Play
   * @summary SoftSwiss Play
   * @param {SoftSwissPlayRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SoftswissApi
   */
  public softSwissPlay(body: SoftSwissPlayRequest, options?: AxiosRequestConfig) {
    return SoftswissApiFp(this.configuration)
      .softSwissPlay(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * SoftSwiss Rollback
   * @summary SoftSwiss Rollback
   * @param {SoftSwissRollbackRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SoftswissApi
   */
  public softSwissRollback(body: SoftSwissRollbackRequest, options?: AxiosRequestConfig) {
    return SoftswissApiFp(this.configuration)
      .softSwissRollback(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Softswiss Demo Game
   * @summary Softswiss Demo Game
   * @param {SoftSwissDemoGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SoftswissApi
   */
  public softswissDemoGame(body: SoftSwissDemoGameRequest, options?: AxiosRequestConfig) {
    return SoftswissApiFp(this.configuration)
      .softswissDemoGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Start Softswiss game
   * @summary Start Softswiss game
   * @param {SoftSwissStartGameRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SoftswissApi
   */
  public softswissStartGame(body: SoftSwissStartGameRequest, options?: AxiosRequestConfig) {
    return SoftswissApiFp(this.configuration)
      .softswissStartGame(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Uploads games file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SoftswissApi
   */
  public v1SoftswissGamesUploadPost(options?: AxiosRequestConfig) {
    return SoftswissApiFp(this.configuration)
      .v1SoftswissGamesUploadPost(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Chanage casino player password
     * @summary Change password
     * @param {ChangePasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (body: ChangePasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('changePassword', 'body', body);
      const localVarPath = `/v1/user/changePassword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reset casino player password
     * @summary Reset password
     * @param {ResetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword: async (body: ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('resetPassword', 'body', body);
      const localVarPath = `/v1/user/resetPassword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Chanage casino player password
     * @summary Change password
     * @param {ChangePasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      body: ChangePasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePasswordResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Reset casino player password
     * @summary Reset password
     * @param {ResetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetPassword(
      body: ResetPasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetPasswordResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * Chanage casino player password
     * @summary Change password
     * @param {ChangePasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(body: ChangePasswordRequest, options?: any): AxiosPromise<ChangePasswordResponse> {
      return localVarFp.changePassword(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Reset casino player password
     * @summary Reset password
     * @param {ResetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(body: ResetPasswordRequest, options?: any): AxiosPromise<ResetPasswordResponse> {
      return localVarFp.resetPassword(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Chanage casino player password
   * @summary Change password
   * @param {ChangePasswordRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public changePassword(body: ChangePasswordRequest, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .changePassword(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Reset casino player password
   * @summary Reset password
   * @param {ResetPasswordRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public resetPassword(body: ResetPasswordRequest, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .resetPassword(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VeriffApi - axios parameter creator
 * @export
 */
export const VeriffApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get result of the Veriff verification
     * @summary Get result of the Veriff verification
     * @param {string} xAUTHCLIENT
     * @param {string} xHMACSIGNATURE
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    veriffDecision: async (
      xAUTHCLIENT: string,
      xHMACSIGNATURE: string,
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'xAUTHCLIENT' is not null or undefined
      assertParamExists('veriffDecision', 'xAUTHCLIENT', xAUTHCLIENT);
      // verify required parameter 'xHMACSIGNATURE' is not null or undefined
      assertParamExists('veriffDecision', 'xHMACSIGNATURE', xHMACSIGNATURE);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('veriffDecision', 'body', body);
      const localVarPath = `/v1/veriff/decision`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xAUTHCLIENT !== undefined && xAUTHCLIENT !== null) {
        localVarHeaderParameter['X-AUTH-CLIENT'] = String(xAUTHCLIENT);
      }

      if (xHMACSIGNATURE !== undefined && xHMACSIGNATURE !== null) {
        localVarHeaderParameter['X-HMAC-SIGNATURE'] = String(xHMACSIGNATURE);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get event of the Veriff verification
     * @summary Get event of the Veriff verification
     * @param {string} xAUTHCLIENT
     * @param {string} xHMACSIGNATURE
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    veriffEvent: async (
      xAUTHCLIENT: string,
      xHMACSIGNATURE: string,
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'xAUTHCLIENT' is not null or undefined
      assertParamExists('veriffEvent', 'xAUTHCLIENT', xAUTHCLIENT);
      // verify required parameter 'xHMACSIGNATURE' is not null or undefined
      assertParamExists('veriffEvent', 'xHMACSIGNATURE', xHMACSIGNATURE);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('veriffEvent', 'body', body);
      const localVarPath = `/v1/veriff/event`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xAUTHCLIENT !== undefined && xAUTHCLIENT !== null) {
        localVarHeaderParameter['X-AUTH-CLIENT'] = String(xAUTHCLIENT);
      }

      if (xHMACSIGNATURE !== undefined && xHMACSIGNATURE !== null) {
        localVarHeaderParameter['X-HMAC-SIGNATURE'] = String(xHMACSIGNATURE);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VeriffApi - functional programming interface
 * @export
 */
export const VeriffApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VeriffApiAxiosParamCreator(configuration);
  return {
    /**
     * Get result of the Veriff verification
     * @summary Get result of the Veriff verification
     * @param {string} xAUTHCLIENT
     * @param {string} xHMACSIGNATURE
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async veriffDecision(
      xAUTHCLIENT: string,
      xHMACSIGNATURE: string,
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.veriffDecision(
        xAUTHCLIENT,
        xHMACSIGNATURE,
        body,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get event of the Veriff verification
     * @summary Get event of the Veriff verification
     * @param {string} xAUTHCLIENT
     * @param {string} xHMACSIGNATURE
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async veriffEvent(
      xAUTHCLIENT: string,
      xHMACSIGNATURE: string,
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.veriffEvent(xAUTHCLIENT, xHMACSIGNATURE, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * VeriffApi - factory interface
 * @export
 */
export const VeriffApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = VeriffApiFp(configuration);
  return {
    /**
     * Get result of the Veriff verification
     * @summary Get result of the Veriff verification
     * @param {string} xAUTHCLIENT
     * @param {string} xHMACSIGNATURE
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    veriffDecision(xAUTHCLIENT: string, xHMACSIGNATURE: string, body: object, options?: any): AxiosPromise<void> {
      return localVarFp
        .veriffDecision(xAUTHCLIENT, xHMACSIGNATURE, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get event of the Veriff verification
     * @summary Get event of the Veriff verification
     * @param {string} xAUTHCLIENT
     * @param {string} xHMACSIGNATURE
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    veriffEvent(xAUTHCLIENT: string, xHMACSIGNATURE: string, body: object, options?: any): AxiosPromise<void> {
      return localVarFp
        .veriffEvent(xAUTHCLIENT, xHMACSIGNATURE, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VeriffApi - object-oriented interface
 * @export
 * @class VeriffApi
 * @extends {BaseAPI}
 */
export class VeriffApi extends BaseAPI {
  /**
   * Get result of the Veriff verification
   * @summary Get result of the Veriff verification
   * @param {string} xAUTHCLIENT
   * @param {string} xHMACSIGNATURE
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VeriffApi
   */
  public veriffDecision(xAUTHCLIENT: string, xHMACSIGNATURE: string, body: object, options?: AxiosRequestConfig) {
    return VeriffApiFp(this.configuration)
      .veriffDecision(xAUTHCLIENT, xHMACSIGNATURE, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get event of the Veriff verification
   * @summary Get event of the Veriff verification
   * @param {string} xAUTHCLIENT
   * @param {string} xHMACSIGNATURE
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VeriffApi
   */
  public veriffEvent(xAUTHCLIENT: string, xHMACSIGNATURE: string, body: object, options?: AxiosRequestConfig) {
    return VeriffApiFp(this.configuration)
      .veriffEvent(xAUTHCLIENT, xHMACSIGNATURE, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WithdrawalsApi - axios parameter creator
 * @export
 */
export const WithdrawalsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * approve withdraw
     * @summary approve withdraw
     * @param {number} id Player internal ID
     * @param {ApproveWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveWithdraw: async (
      id: number,
      body: ApproveWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('approveWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('approveWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/approve`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * cancel withdraw
     * @summary cancel withdraw
     * @param {number} id Player internal ID
     * @param {CancelWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelWithdraw: async (
      id: number,
      body: CancelWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('cancelWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('cancelWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/cancel`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Confirm withdraw by player
     * @summary confirm withdraw by player
     * @param {number} id Player internal ID
     * @param {ConfirmWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmWithdraw: async (
      id: number,
      body: ConfirmWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('confirmWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('confirmWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/confirm`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Execute withdraw
     * @summary execute withdraw
     * @param {number} id Player internal ID
     * @param {ExecuteWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeWithdraw: async (
      id: number,
      body: ExecuteWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('executeWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('executeWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/execute`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * fail withdraw
     * @summary fail withdraw
     * @param {number} id Player internal ID
     * @param {FailWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    failWithdraw: async (
      id: number,
      body: FailWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('failWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('failWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/fail`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * freeze withdraw
     * @summary freeze withdraw
     * @param {number} id Player internal ID
     * @param {FreezeWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freezeWithdraw: async (
      id: number,
      body: FreezeWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('freezeWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('freezeWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/freeze`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * reject withdraw
     * @summary reject withdraw
     * @param {number} id Player internal ID
     * @param {RejectWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectWithdraw: async (
      id: number,
      body: RejectWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('rejectWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('rejectWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/reject`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Make withdraw request
     * @summary request withdraw
     * @param {number} id Player internal ID
     * @param {RequestWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestWithdraw: async (
      id: number,
      body: RequestWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('requestWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('requestWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/request`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retry withdraw
     * @summary retry withdraw
     * @param {number} id Player internal ID
     * @param {RetryWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retryWithdraw: async (
      id: number,
      body: RetryWithdrawRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('retryWithdraw', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('retryWithdraw', 'body', body);
      const localVarPath = `/v1/players/{id}/withdraw/retry`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WithdrawalsApi - functional programming interface
 * @export
 */
export const WithdrawalsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WithdrawalsApiAxiosParamCreator(configuration);
  return {
    /**
     * approve withdraw
     * @summary approve withdraw
     * @param {number} id Player internal ID
     * @param {ApproveWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async approveWithdraw(
      id: number,
      body: ApproveWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.approveWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * cancel withdraw
     * @summary cancel withdraw
     * @param {number} id Player internal ID
     * @param {CancelWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelWithdraw(
      id: number,
      body: CancelWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Confirm withdraw by player
     * @summary confirm withdraw by player
     * @param {number} id Player internal ID
     * @param {ConfirmWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmWithdraw(
      id: number,
      body: ConfirmWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirmWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Execute withdraw
     * @summary execute withdraw
     * @param {number} id Player internal ID
     * @param {ExecuteWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeWithdraw(
      id: number,
      body: ExecuteWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * fail withdraw
     * @summary fail withdraw
     * @param {number} id Player internal ID
     * @param {FailWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async failWithdraw(
      id: number,
      body: FailWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.failWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * freeze withdraw
     * @summary freeze withdraw
     * @param {number} id Player internal ID
     * @param {FreezeWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async freezeWithdraw(
      id: number,
      body: FreezeWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.freezeWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * reject withdraw
     * @summary reject withdraw
     * @param {number} id Player internal ID
     * @param {RejectWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rejectWithdraw(
      id: number,
      body: RejectWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rejectWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Make withdraw request
     * @summary request withdraw
     * @param {number} id Player internal ID
     * @param {RequestWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestWithdraw(
      id: number,
      body: RequestWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retry withdraw
     * @summary retry withdraw
     * @param {number} id Player internal ID
     * @param {RetryWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retryWithdraw(
      id: number,
      body: RetryWithdrawRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retryWithdraw(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * WithdrawalsApi - factory interface
 * @export
 */
export const WithdrawalsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WithdrawalsApiFp(configuration);
  return {
    /**
     * approve withdraw
     * @summary approve withdraw
     * @param {number} id Player internal ID
     * @param {ApproveWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveWithdraw(id: number, body: ApproveWithdrawRequest, options?: any): AxiosPromise<void> {
      return localVarFp.approveWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * cancel withdraw
     * @summary cancel withdraw
     * @param {number} id Player internal ID
     * @param {CancelWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelWithdraw(id: number, body: CancelWithdrawRequest, options?: any): AxiosPromise<void> {
      return localVarFp.cancelWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Confirm withdraw by player
     * @summary confirm withdraw by player
     * @param {number} id Player internal ID
     * @param {ConfirmWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmWithdraw(id: number, body: ConfirmWithdrawRequest, options?: any): AxiosPromise<WithdrawResponse> {
      return localVarFp.confirmWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Execute withdraw
     * @summary execute withdraw
     * @param {number} id Player internal ID
     * @param {ExecuteWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeWithdraw(id: number, body: ExecuteWithdrawRequest, options?: any): AxiosPromise<WithdrawResponse> {
      return localVarFp.executeWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * fail withdraw
     * @summary fail withdraw
     * @param {number} id Player internal ID
     * @param {FailWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    failWithdraw(id: number, body: FailWithdrawRequest, options?: any): AxiosPromise<WithdrawResponse> {
      return localVarFp.failWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * freeze withdraw
     * @summary freeze withdraw
     * @param {number} id Player internal ID
     * @param {FreezeWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freezeWithdraw(id: number, body: FreezeWithdrawRequest, options?: any): AxiosPromise<WithdrawResponse> {
      return localVarFp.freezeWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * reject withdraw
     * @summary reject withdraw
     * @param {number} id Player internal ID
     * @param {RejectWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectWithdraw(id: number, body: RejectWithdrawRequest, options?: any): AxiosPromise<WithdrawResponse> {
      return localVarFp.rejectWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Make withdraw request
     * @summary request withdraw
     * @param {number} id Player internal ID
     * @param {RequestWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestWithdraw(id: number, body: RequestWithdrawRequest, options?: any): AxiosPromise<WithdrawResponse> {
      return localVarFp.requestWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Retry withdraw
     * @summary retry withdraw
     * @param {number} id Player internal ID
     * @param {RetryWithdrawRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retryWithdraw(id: number, body: RetryWithdrawRequest, options?: any): AxiosPromise<WithdrawResponse> {
      return localVarFp.retryWithdraw(id, body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * WithdrawalsApi - object-oriented interface
 * @export
 * @class WithdrawalsApi
 * @extends {BaseAPI}
 */
export class WithdrawalsApi extends BaseAPI {
  /**
   * approve withdraw
   * @summary approve withdraw
   * @param {number} id Player internal ID
   * @param {ApproveWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public approveWithdraw(id: number, body: ApproveWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .approveWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * cancel withdraw
   * @summary cancel withdraw
   * @param {number} id Player internal ID
   * @param {CancelWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public cancelWithdraw(id: number, body: CancelWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .cancelWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Confirm withdraw by player
   * @summary confirm withdraw by player
   * @param {number} id Player internal ID
   * @param {ConfirmWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public confirmWithdraw(id: number, body: ConfirmWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .confirmWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Execute withdraw
   * @summary execute withdraw
   * @param {number} id Player internal ID
   * @param {ExecuteWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public executeWithdraw(id: number, body: ExecuteWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .executeWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * fail withdraw
   * @summary fail withdraw
   * @param {number} id Player internal ID
   * @param {FailWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public failWithdraw(id: number, body: FailWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .failWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * freeze withdraw
   * @summary freeze withdraw
   * @param {number} id Player internal ID
   * @param {FreezeWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public freezeWithdraw(id: number, body: FreezeWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .freezeWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * reject withdraw
   * @summary reject withdraw
   * @param {number} id Player internal ID
   * @param {RejectWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public rejectWithdraw(id: number, body: RejectWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .rejectWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Make withdraw request
   * @summary request withdraw
   * @param {number} id Player internal ID
   * @param {RequestWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public requestWithdraw(id: number, body: RequestWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .requestWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retry withdraw
   * @summary retry withdraw
   * @param {number} id Player internal ID
   * @param {RetryWithdrawRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WithdrawalsApi
   */
  public retryWithdraw(id: number, body: RetryWithdrawRequest, options?: AxiosRequestConfig) {
    return WithdrawalsApiFp(this.configuration)
      .retryWithdraw(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
